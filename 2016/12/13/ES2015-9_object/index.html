<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavsScript,ES2015," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="对象的扩展

属性的简洁表示法ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
var foo = &amp;apos;bar&amp;apos;;
var baz = {foo};
baz // {foo: &amp;quot;bar&amp;quot;}

// 等同于
var baz = {foo: foo};
上面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的">
<meta property="og:type" content="article">
<meta property="og:title" content="ES2015——9.对象的扩展">
<meta property="og:url" content="http://yoursite.com/2016/12/13/ES2015-9_object/index.html">
<meta property="og:site_name" content="zhuoyue">
<meta property="og:description" content="对象的扩展

属性的简洁表示法ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
var foo = &amp;apos;bar&amp;apos;;
var baz = {foo};
baz // {foo: &amp;quot;bar&amp;quot;}

// 等同于
var baz = {foo: foo};
上面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的">
<meta property="og:updated_time" content="2017-06-26T08:42:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES2015——9.对象的扩展">
<meta name="twitter:description" content="对象的扩展

属性的简洁表示法ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。
var foo = &amp;apos;bar&amp;apos;;
var baz = {foo};
baz // {foo: &amp;quot;bar&amp;quot;}

// 等同于
var baz = {foo: foo};
上面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/12/13/ES2015-9_object/"/>

  <title> ES2015——9.对象的扩展 | zhuoyue </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?c01c0e51b835643529ad3c2911ec1bb0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">zhuoyue</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">+1s</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ES2015——9.对象的扩展
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-13T11:50:39+08:00" content="2016-12-13 11:50:39">
              2016-12-13 11:50:39
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/13/ES2015-9_object/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/13/ES2015-9_object/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p><a href="http://es6.ruanyifeng.com/#docs/object" target="_blank" rel="external">对象的扩展</a></p>
</blockquote>
<h3 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h3><p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<pre><code>var foo = &apos;bar&apos;;
var baz = {foo};
baz // {foo: &quot;bar&quot;}

// 等同于
var baz = {foo: foo};
</code></pre><p>上面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。</p>
<pre><code>function f(x, y) {
  return {x, y};
}

// 等同于

function f(x, y) {
  return {x: x, y: y};
}

f(1, 2) // Object {x: 1, y: 2}
</code></pre><p>除了属性简写，方法也可以简写。</p>
<pre><code>var o = {
  method() {
    return &quot;Hello!&quot;;
  }
};

// 等同于

var o = {
  method: function() {
    return &quot;Hello!&quot;;
  }
};
</code></pre><p>下面是一个实际的例子。</p>
<pre><code>var birth = &apos;2000/01/01&apos;;

var Person = {

  name: &apos;张三&apos;,

  //等同于birth: birth
  birth,

  // 等同于hello: function ()...
  hello() { console.log(&apos;我的名字是&apos;, this.name); }

};
</code></pre><p>这种写法用于函数的返回值，将会非常方便。</p>
<pre><code>function getPoint() {
  var x = 1;
  var y = 10;
  return {x, y};
}

getPoint()
// {x:1, y:10}
</code></pre><p>CommonJS模块输出变量，就非常合适使用简洁写法。</p>
<pre><code>var ms = {};

function getItem (key) {
  return key in ms ? ms[key] : null;
}

function setItem (key, value) {
  ms[key] = value;
}

function clear () {
  ms = {};
}

module.exports = { getItem, setItem, clear };
// 等同于
module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};
</code></pre><p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p>
<pre><code>var cart = {
  _wheels: 4,

  get wheels () {
    return this._wheels;
  },

  set wheels (value) {
    if (value &lt; this._wheels) {
      throw new Error(&apos;数值太小了！&apos;);
    }
    this._wheels = value;
  }
}
</code></pre><p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p>
<pre><code>var obj = {
  class () {}
};

// 等同于

var obj = {
  &apos;class&apos;: function() {}
};
</code></pre><p>上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p>
<p>如果某个方法的值是一个Generator函数，前面需要加上星号。</p>
<pre><code>var obj = {
  * m(){
    yield &apos;hello world&apos;;
  }
};
</code></pre><h3 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h3><p>JavaScript语言定义对象的属性，有两种方法。</p>
<pre><code>// 方法一
obj.foo = true;

// 方法二
obj[&apos;a&apos; + &apos;bc&apos;] = 123;
</code></pre><p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。  </p>
<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p>
<pre><code>var obj = {
  foo: true,
  abc: 123
};
</code></pre><p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<pre><code>let propKey = &apos;foo&apos;;

let obj = {
  [propKey]: true,
  [&apos;a&apos; + &apos;bc&apos;]: 123
};
</code></pre><p>下面是另一个例子。</p>
<pre><code>var lastWord = &apos;last word&apos;;

var a = {
  &apos;first word&apos;: &apos;hello&apos;,
  [lastWord]: &apos;world&apos;
};

a[&apos;first word&apos;] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a[&apos;last word&apos;] // &quot;world&quot;
</code></pre><p>表达式还可以用于定义方法名。</p>
<pre><code>let obj = {
  [&apos;h&apos; + &apos;ello&apos;]() {
    return &apos;hi&apos;;
  }
};

obj.hello() // hi
</code></pre><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>
<pre><code>// 报错
var foo = &apos;bar&apos;;
var bar = &apos;abc&apos;;
var baz = { [foo] };

// 正确
var foo = &apos;bar&apos;;
var baz = { [foo]: &apos;abc&apos;};
</code></pre><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。</p>
<pre><code>const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: &apos;valueA&apos;,
  [keyB]: &apos;valueB&apos;
};

myObject // Object {[object Object]: &quot;valueB&quot;}
</code></pre><p>上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。</p>
<h3 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h3><p>函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。</p>
<pre><code>var person = {
  sayName() {
    console.log(this.name);
  },
  get firstName() {
    return &quot;Nicholas&quot;;
  }
};

person.sayName.name   // &quot;sayName&quot;
person.firstName.name // &quot;get firstName&quot;
</code></pre><p>上面代码中，方法的name属性返回函数名（即方法名）。如果使用了取值函数，则会在方法名前加上get。如果是存值函数，方法名的前面会加上set。  </p>
<p>有两种特殊情况：bind方法创造的函数，name属性返回“bound”加上原函数的名字；Function构造函数创造的函数，name属性返回“anonymous”。</p>
<pre><code>(new Function()).name // &quot;anonymous&quot;

var doSomething = function() {
  // ...
};
doSomething.bind().name // &quot;bound doSomething&quot;
</code></pre><p>如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述。</p>
<pre><code>const key1 = Symbol(&apos;description&apos;);
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // &quot;[description]&quot;
obj[key2].name // &quot;&quot;
</code></pre><p>上面代码中，key1对应的Symbol值有描述，key2没有。</p>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。  </p>
<p>ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<pre><code>Object.is(&apos;foo&apos;, &apos;foo&apos;)
// true
Object.is({}, {})
// false
</code></pre><p>不同之处只有两个：一是+0不等于-0，二是NaN等于自身。</p>
<pre><code>+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre><p>ES5可以通过下面的代码，部署Object.is。</p>
<pre><code>Object.defineProperty(Object, &apos;is&apos;, {
  value: function(x, y) {
    if (x === y) {
      // 针对+0 不等于 -0的情况
      return x !== 0 || 1 / x === 1 / y;
    }
    // 针对NaN的情况
    return x !== x &amp;&amp; y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true
});
</code></pre><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<pre><code>var target = { a: 1 };

var source1 = { b: 2 };
var source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre><p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。  </p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<pre><code>var target = { a: 1, b: 1 };

var source1 = { b: 2, c: 2 };
var source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre><p>如果只有一个参数，Object.assign会直接返回该参数。</p>
<pre><code>var obj = {a: 1};
Object.assign(obj) === obj // true
</code></pre><p>如果该参数不是对象，则会先转成对象，然后返回。</p>
<pre><code>typeof Object.assign(2) // &quot;object&quot;
</code></pre><p>由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。</p>
<pre><code>Object.assign(undefined) // 报错
Object.assign(null) // 报错
</code></pre><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。</p>
<pre><code>let obj = {a: 1};
Object.assign(obj, undefined) === obj // true
Object.assign(obj, null) === obj // true
</code></pre><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p>
<pre><code>var v1 = &apos;abc&apos;;
var v2 = true;
var v3 = 10;

var obj = Object.assign({}, v1, v2, v3);
console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }
</code></pre><p>上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>
<pre><code>Object(true) // {[[PrimitiveValue]]: true}
Object(10)  //  {[[PrimitiveValue]]: 10}
Object(&apos;abc&apos;) // {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;}
</code></pre><p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。  </p>
<p>Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。</p>
<pre><code>Object.assign({b: &apos;c&apos;},
  Object.defineProperty({}, &apos;invisible&apos;, {
    enumerable: false,
    value: &apos;hello&apos;
  })
)
// { b: &apos;c&apos; }
</code></pre><p>上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。  </p>
<p>属性名为Symbol值的属性，也会被Object.assign拷贝。</p>
<pre><code>Object.assign({ a: &apos;b&apos; }, { [Symbol(&apos;c&apos;)]: &apos;d&apos; })
// { a: &apos;b&apos;, Symbol(c): &apos;d&apos; }
</code></pre><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<pre><code>var obj1 = {a: {b: 1}};
var obj2 = Object.assign({}, obj1);

obj1.a.b = 2;
obj2.a.b // 2
</code></pre><p>上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。  </p>
<p>对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。</p>
<pre><code>var target = { a: { b: &apos;c&apos;, d: &apos;e&apos; } }
var source = { a: { b: &apos;hello&apos; } }
Object.assign(target, source)
// { a: { b: &apos;hello&apos; } }
</code></pre><p>上面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{ a: { b: ‘hello’, d: ‘e’ } }的结果。这通常不是开发者想要的，需要特别小心。  </p>
<p>有一些函数库提供Object.assign的定制版本（比如Lodash的_.defaultsDeep方法），可以解决浅拷贝的问题，得到深拷贝的合并。  </p>
<p>注意，Object.assign可以用来处理数组，但是会把数组视为对象。</p>
<pre><code>Object.assign([1, 2, 3], [4, 5])
// [4, 5, 3]
</code></pre><p>上面代码中，Object.assign把数组视为属性名为0、1、2的对象，因此目标数组的0号属性4覆盖了原数组的0号属性1。</p>
<h4 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h4><p>Object.assign方法有很多用处。</p>
<h5 id="为对象添加属性"><a href="#为对象添加属性" class="headerlink" title="为对象添加属性"></a>为对象添加属性</h5><pre><code>class Point {
  constructor(x, y) {
    Object.assign(this, {x, y});
  }
}
</code></pre><p>上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。</p>
<h5 id="为对象添加方法"><a href="#为对象添加方法" class="headerlink" title="为对象添加方法"></a>为对象添加方法</h5><pre><code>Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
</code></pre><p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。</p>
<h5 id="克隆对象"><a href="#克隆对象" class="headerlink" title="克隆对象"></a>克隆对象</h5><pre><code>function clone(origin) {
  return Object.assign({}, origin);
}
</code></pre><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。  </p>
<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<pre><code>function clone(origin) {
  let originProto = Object.getPrototypeOf(origin);
  return Object.assign(Object.create(originProto), origin);
}
</code></pre><h5 id="合并多个对象"><a href="#合并多个对象" class="headerlink" title="合并多个对象"></a>合并多个对象</h5><p>将多个对象合并到某个对象。</p>
<pre><code>const merge =
  (target, ...sources) =&gt; Object.assign(target, ...sources);
</code></pre><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>
<pre><code>const merge =
  (...sources) =&gt; Object.assign({}, ...sources);
</code></pre><h5 id="为属性指定默认值"><a href="#为属性指定默认值" class="headerlink" title="为属性指定默认值"></a>为属性指定默认值</h5><pre><code>const DEFAULTS = {
  logLevel: 0,
  outputFormat: &apos;html&apos;
};

function processContent(options) {
  options = Object.assign({}, DEFAULTS, options);
}
</code></pre><p>上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值。  </p>
<p>注意，由于存在深拷贝的问题，DEFAULTS对象和options对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。否则，将导致DEFAULTS对象的该属性不起作用。</p>
<h3 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h3><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。  </p>
<pre><code>let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
</code></pre><p>描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。  </p>
<p>ES5有三个操作会忽略enumerable为false的属性。</p>
<ul>
<li>for…in循环：只遍历对象自身的和继承的可枚举的属性</li>
<li>Object.keys()：返回对象自身的所有可枚举的属性的键名</li>
<li>JSON.stringify()：只串行化对象自身的可枚举的属性</li>
</ul>
<p>ES6新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。  </p>
<p>这四个操作之中，只有for…in会返回继承的属性。实际上，引入enumerable的最初目的，就是让某些属性可以规避掉for…in操作。比如，对象原型的toString方法，以及数组的length属性，就通过这种手段，不会被for…in遍历到。</p>
<pre><code>Object.getOwnPropertyDescriptor(Object.prototype, &apos;toString&apos;).enumerable
// false

Object.getOwnPropertyDescriptor([], &apos;length&apos;).enumerable
// false
</code></pre><p>上面代码中，toString和length属性的enumerable都是false，因此for…in不会遍历到这两个继承自原型的属性。  </p>
<p>另外，ES6规定，所有Class的原型的方法都是不可枚举的。</p>
<pre><code>Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, &apos;foo&apos;).enumerable
// false
</code></pre><p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for…in循环，而用Object.keys()代替。</p>
<h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><p>ES6一共有5种方法可以遍历对象的属性。</p>
<h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p>for…in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</p>
<h4 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h4><p>Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。</p>
<h4 id="Object-getOwnPropertyNames-obj"><a href="#Object-getOwnPropertyNames-obj" class="headerlink" title="Object.getOwnPropertyNames(obj)"></a>Object.getOwnPropertyNames(obj)</h4><p>Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。</p>
<h4 id="Object-getOwnPropertySymbols-obj"><a href="#Object-getOwnPropertySymbols-obj" class="headerlink" title="Object.getOwnPropertySymbols(obj)"></a>Object.getOwnPropertySymbols(obj)</h4><p>Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。</p>
<h4 id="Reflect-ownKeys-obj"><a href="#Reflect-ownKeys-obj" class="headerlink" title="Reflect.ownKeys(obj)"></a>Reflect.ownKeys(obj)</h4><p>Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。  </p>
<p>以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。  </p>
<ul>
<li>首先遍历所有属性名为数值的属性，按照数字排序。</li>
<li>其次遍历所有属性名为字符串的属性，按照生成时间排序。</li>
<li>最后遍历所有属性名为Symbol值的属性，按照生成时间排序。</li>
</ul>
<pre><code>Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })
// [&apos;2&apos;, &apos;10&apos;, &apos;b&apos;, &apos;a&apos;, Symbol()]
</code></pre><p>上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是Symbol属性。</p>
<h3 id="proto属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#proto属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a><strong>proto</strong>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h3><h4 id="proto属性"><a href="#proto属性" class="headerlink" title="proto属性"></a><strong>proto</strong>属性</h4><p><strong>proto</strong>属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括IE11）都部署了这个属性。</p>
<pre><code>// es6的写法
var obj = {
  method: function() { ... }
};
obj.__proto__ = someOtherObj;

// es5的写法
var obj = Object.create(someOtherObj);
obj.method = function() { ... };
</code></pre><p>该属性没有写入ES6的正文，而是写入了附录，原因是<strong>proto</strong>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的API，只是由于浏览器广泛支持，才被加入了ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。  </p>
<p>在实现上，<strong>proto</strong>调用的是Object.prototype.<strong>proto</strong>，具体实现如下。  </p>
<pre><code>Object.defineProperty(Object.prototype, &apos;__proto__&apos;, {
  get() {
    let _thisObj = Object(this);
    return Object.getPrototypeOf(_thisObj);
  },
  set(proto) {
    if (this === undefined || this === null) {
      throw new TypeError();
    }
    if (!isObject(this)) {
      return undefined;
    }
    if (!isObject(proto)) {
      return undefined;
    }
    let status = Reflect.setPrototypeOf(this, proto);
    if (!status) {
      throw new TypeError();
    }
  },
});
function isObject(value) {
  return Object(value) === value;
}
</code></pre><p>如果一个对象本身部署了<strong>proto</strong>属性，则该属性的值就是对象的原型。</p>
<pre><code>Object.getPrototypeOf({ __proto__: null })
// null
</code></pre><h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><p>Object.setPrototypeOf方法的作用与<strong>proto</strong>相同，用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。</p>
<pre><code>// 格式
Object.setPrototypeOf(object, prototype)

// 用法
var o = Object.setPrototypeOf({}, null);
</code></pre><p>该方法等同于下面的函数。</p>
<pre><code>function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
</code></pre><p>下面是一个例子。</p>
<pre><code>let proto = {};
let obj = { x: 10 };
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
</code></pre><p>上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。  </p>
<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>该方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象。</p>
<pre><code>Object.getPrototypeOf(obj);
</code></pre><p>下面是一个例子。</p>
<pre><code>function Rectangle() {
}

var rec = new Rectangle();

Object.getPrototypeOf(rec) === Rectangle.prototype
// true

Object.setPrototypeOf(rec, Object.prototype);
Object.getPrototypeOf(rec) === Rectangle.prototype
// false
</code></pre><h3 id="Object-values-，Object-entries"><a href="#Object-values-，Object-entries" class="headerlink" title="Object.values()，Object.entries()"></a>Object.values()，Object.entries()</h3><h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>ES5引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<pre><code>var obj = { foo: &quot;bar&quot;, baz: 42 };
Object.keys(obj)
// [&quot;foo&quot;, &quot;baz&quot;]
</code></pre><p>目前，ES7有一个提案，引入了跟Object.keys配套的Object.values和Object.entries。</p>
<pre><code>let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // &apos;a&apos;, &apos;b&apos;, &apos;c&apos;
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // [&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]
}
</code></pre><h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h4><p>Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<pre><code>var obj = { foo: &quot;bar&quot;, baz: 42 };
Object.values(obj)
// [&quot;bar&quot;, 42]
</code></pre><p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>
<pre><code>var obj = { 100: &apos;a&apos;, 2: &apos;b&apos;, 7: &apos;c&apos; };
Object.values(obj)
// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]
</code></pre><p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。  </p>
<p>Object.values只返回对象自身的可遍历属性。</p>
<pre><code>var obj = Object.create({}, {p: {value: 42}});
Object.values(obj) // []
</code></pre><p>上面代码中，Object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的。Object.values不会返回这个属性。  </p>
<p>Object.values会过滤属性名为Symbol值的属性。</p>
<pre><code>Object.values({ [Symbol()]: 123, foo: &apos;abc&apos; });
// [&apos;abc&apos;]
</code></pre><p>如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>
<pre><code>Object.values(&apos;foo&apos;)
// [&apos;f&apos;, &apos;o&apos;, &apos;o&apos;]
</code></pre><p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values返回每个属性的键值，就是各个字符组成的一个数组。  </p>
<p>如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。</p>
<pre><code>Object.values(42) // []
Object.values(true) // []
</code></pre><h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h4><p>Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<pre><code>var obj = { foo: &apos;bar&apos;, baz: 42 };
Object.entries(obj)
// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]
</code></pre><p>除了返回值不一样，该方法的行为与Object.values基本一致。  </p>
<p>如果原对象的属性名是一个Symbol值，该属性会被省略。</p>
<pre><code>Object.entries({ [Symbol()]: 123, foo: &apos;abc&apos; });
// [ [ &apos;foo&apos;, &apos;abc&apos; ] ]
</code></pre><p>上面代码中，原对象有两个属性，Object.entries只输出属性名非Symbol值的属性。将来可能会有Reflect.ownEntries()方法，返回对象自身的所有属性。  </p>
<p>Object.entries的基本用途是遍历对象的属性。</p>
<pre><code>let obj = { one: 1, two: 2 };
for (let [k, v] of Object.entries(obj)) {
  console.log(`${JSON.stringify(k)}: ${JSON.stringify(v)}`);
}
// &quot;one&quot;: 1
// &quot;two&quot;: 2
</code></pre><p>Object.entries方法的一个用处是，将对象转为真正的Map结构。</p>
<pre><code>var obj = { foo: &apos;bar&apos;, baz: 42 };
var map = new Map(Object.entries(obj));
map // Map { foo: &quot;bar&quot;, baz: 42 }
</code></pre><p>自己实现Object.entries方法，非常简单。</p>
<pre><code>// Generator函数的版本
function* entries(obj) {
  for (let key of Object.keys(obj)) {
    yield [key, obj[key]];
  }
}

// 非Generator函数的版本
function entries(obj) {
  let arr = [];
  for (let key of Object.keys(obj)) {
    arr.push([key, obj[key]]);
  }
  return arr;
}
</code></pre><h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h3><p>目前，ES7有一个提案，将Rest运算符（解构赋值）/扩展运算符（…）引入对象。Babel转码器已经支持这项功能。</p>
<h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<pre><code>let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
</code></pre><p>上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。  </p>
<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。</p>
<pre><code>let { x, y, ...z } = null; // 运行时错误
let { x, y, ...z } = undefined; // 运行时错误
</code></pre><p>解构赋值必须是最后一个参数，否则会报错。</p>
<pre><code>let { ...x, y, z } = obj; // 句法错误
let { x, ...y, ...z } = obj; // 句法错误
</code></pre><p>上面代码中，解构赋值不是最后一个参数，所以会报错。  </p>
<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>
<pre><code>let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2;
x.a.b // 2
</code></pre><p>上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。  </p>
<p>另外，解构赋值不会拷贝继承自原型对象的属性。</p>
<pre><code>let o1 = { a: 1 };
let o2 = { b: 2 };
o2.__proto__ = o1;
let o3 = { ...o2 };
o3 // { b: 2 }
</code></pre><p>上面代码中，对象o3是o2的拷贝，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。  </p>
<p>下面是另一个例子。</p>
<pre><code>var o = Object.create({ x: 1, y: 2 });
o.z = 3;

let { x, ...{ y, z } } = o;
x // 1
y // undefined
z // 3
</code></pre><p>上面代码中，变量x是单纯的解构赋值，所以可以读取继承的属性；解构赋值产生的变量y和z，只能读取对象自身的属性，所以只有变量z可以赋值成功。  </p>
<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p>
<pre><code>function baseFunction({ a, b }) {
  // ...
}
function wrapperFunction({ x, y, ...restConfig }) {
  // 使用x和y参数进行操作
  // 其余参数传给原始函数
  return baseFunction(restConfig);
}
</code></pre><p>上面代码中，原始函数baseFunction接受a和b作为参数，函数wrapperFunction在baseFunction的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>
<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<pre><code>let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
</code></pre><p>这等同于使用Object.assign方法。</p>
<pre><code>let aClone = { ...a };
// 等同于
let aClone = Object.assign({}, a);
</code></pre><p>扩展运算符可以用于合并两个对象。</p>
<pre><code>let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
</code></pre><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<pre><code>let aWithOverrides = { ...a, x: 1, y: 2 };
// 等同于
let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };
// 等同于
let x = 1, y = 2, aWithOverrides = { ...a, x, y };
// 等同于
let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });
</code></pre><p>上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。  </p>
<p>这用来修改现有对象部分的部分属性就很方便了。</p>
<pre><code>let newVersion = {
  ...previousVersion,
  name: &apos;New Name&apos; // Override the name property
};
</code></pre><p>上面代码中，newVersion对象自定义了name属性，其他属性全部复制自previousVersion对象。  </p>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<pre><code>let aWithDefaults = { x: 1, y: 2, ...a };
// 等同于
let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);
// 等同于
let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);
</code></pre><p>扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。</p>
<pre><code>// 并不会抛出错误，因为x属性只是被定义，但没执行
let aWithXGetter = {
  ...a,
  get x() {
    throws new Error(&apos;not thrown yet&apos;);
  }
};

// 会抛出错误，因为x属性被执行了
let runtimeError = {
  ...a,
  ...{
    get x() {
      throws new Error(&apos;thrown now&apos;);
    }
  }
};
</code></pre><p>如果扩展运算符的参数是null或undefined，这个两个值会被忽略，不会报错。</p>
<pre><code>let emptyObject = { ...null, ...undefined }; // 不报错
</code></pre><h3 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h3><p>ES5有一个Object.getOwnPropertyDescriptor方法，返回某个对象属性的描述对象（descriptor）。</p>
<pre><code>var obj = { p: &apos;a&apos; };

Object.getOwnPropertyDescriptor(obj, &apos;p&apos;)
// Object { value: &quot;a&quot;,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
</code></pre><p>ES7有一个提案，提出了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<pre><code>const obj = {
  foo: 123,
  get bar() { return &apos;abc&apos; }
};

Object.getOwnPropertyDescriptors(obj)
// { foo:
//    { value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true },
//   bar:
//    { get: [Function: bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true } }
</code></pre><p>Object.getOwnPropertyDescriptors方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。  </p>
<p>该方法的实现非常容易。</p>
<pre><code>function getOwnPropertyDescriptors(obj) {
  const result = {};
  for (let key of Reflect.ownKeys(obj)) {
    result[key] = Object.getOwnPropertyDescriptor(obj, key);
  }
  return result;
}
</code></pre><p>该方法的提出目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。</p>
<pre><code>const source = {
  set foo(value) {
    console.log(value);
  }
};

const target1 = {};
Object.assign(target1, source);

Object.getOwnPropertyDescriptor(target1, &apos;foo&apos;)
// { value: undefined,
//   writable: true,
//   enumerable: true,
//   configurable: true }
</code></pre><p>上面代码中，source对象的foo属性的值是一个赋值函数，Object.assign方法将这个属性拷贝给target1对象，结果该属性的值变成了undefined。这是因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。  </p>
<p>这时，Object.getOwnPropertyDescriptors方法配合Object.defineProperties方法，就可以实现正确拷贝。</p>
<pre><code>const source = {
  set foo(value) {
    console.log(value);
  }
};

const target2 = {};
Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
Object.getOwnPropertyDescriptor(target2, &apos;foo&apos;)
// { get: undefined,
//   set: [Function: foo],
//   enumerable: true,
//   configurable: true }
</code></pre><p>上面代码中，将两个对象合并的逻辑提炼出来，就是下面这样。</p>
<pre><code>const shallowMerge = (target, source) =&gt; Object.defineProperties(
  target,
  Object.getOwnPropertyDescriptors(source)
);
Object.getOwnPropertyDescriptors方法的另一个用处，是配合Object.create方法，将对象属性克隆到一个新对象。这属于浅拷贝。

const clone = Object.create(Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj));

// 或者

const shallowClone = (obj) =&gt; Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
</code></pre><p>上面代码会克隆对象obj。  </p>
<p>另外，Object.getOwnPropertyDescriptors方法可以实现，一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p>
<pre><code>const obj = {
  __proto__: prot,
  foo: 123,
};
</code></pre><p>ES6规定<strong>proto</strong>只有浏览器要部署，其他环境不用部署。如果去除<strong>proto</strong>，上面代码就要改成下面这样。</p>
<pre><code>const obj = Object.create(prot);
obj.foo = 123;

// 或者

const obj = Object.assign(
  Object.create(prot),
  {
    foo: 123,
  }
);
</code></pre><p>有了Object.getOwnPropertyDescriptors，我们就有了另一种写法。</p>
<pre><code>const obj = Object.create(
  prot,
  Object.getOwnPropertyDescriptors({
    foo: 123,
  })
);
</code></pre><p>Object.getOwnPropertyDescriptors也可以用来实现Mixin（混入）模式。</p>
<pre><code>let mix = (object) =&gt; ({
  with: (...mixins) =&gt; mixins.reduce(
    (c, mixin) =&gt; Object.create(
      c, Object.getOwnPropertyDescriptors(mixin)
    ), object)
});

// multiple mixins example
let a = {a: &apos;a&apos;};
let b = {b: &apos;b&apos;};
let c = {c: &apos;c&apos;};
let d = mix(c).with(a, b);
</code></pre><p>上面代码中，对象a和b被混入了对象c。  </p>
<p>出于完整性的考虑，Object.getOwnPropertyDescriptors进入标准以后，还会有Reflect.getOwnPropertyDescriptors方法。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://www.luanmingli.com/static/image/wechat-reward-image.png" alt="卓越 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="http://www.luanmingli.com/static/image/alipay-reward-image.png" alt="卓越 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavsScript/" rel="tag">#JavsScript</a>
          
            <a href="/tags/ES2015/" rel="tag">#ES2015</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/12/ES2015-8_function/" rel="next" title="ES2015——8.函数的扩展">
                <i class="fa fa-chevron-left"></i> ES2015——8.函数的扩展
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/13/ES2015-10_symbol/" rel="prev" title="ES2015——10. Symbol">
                ES2015——10. Symbol <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/12/13/ES2015-9_object/"
           data-title="ES2015——9.对象的扩展" data-url="http://yoursite.com/2016/12/13/ES2015-9_object/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://www.luanmingli.com/static/image/head.png"
               alt="卓越" />
          <p class="site-author-name" itemprop="name">卓越</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">125</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">67</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://github.com/Lmingli" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#属性的简洁表示法"><span class="nav-number">1.</span> <span class="nav-text">属性的简洁表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性名表达式"><span class="nav-number">2.</span> <span class="nav-text">属性名表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法的-name-属性"><span class="nav-number">3.</span> <span class="nav-text">方法的 name 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-is"><span class="nav-number">4.</span> <span class="nav-text">Object.is()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-assign"><span class="nav-number">5.</span> <span class="nav-text">Object.assign()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本用法"><span class="nav-number">5.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注意点"><span class="nav-number">5.2.</span> <span class="nav-text">注意点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见用途"><span class="nav-number">5.3.</span> <span class="nav-text">常见用途</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为对象添加属性"><span class="nav-number">5.3.1.</span> <span class="nav-text">为对象添加属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为对象添加方法"><span class="nav-number">5.3.2.</span> <span class="nav-text">为对象添加方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#克隆对象"><span class="nav-number">5.3.3.</span> <span class="nav-text">克隆对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#合并多个对象"><span class="nav-number">5.3.4.</span> <span class="nav-text">合并多个对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为属性指定默认值"><span class="nav-number">5.3.5.</span> <span class="nav-text">为属性指定默认值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性的可枚举性"><span class="nav-number">6.</span> <span class="nav-text">属性的可枚举性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性的遍历"><span class="nav-number">7.</span> <span class="nav-text">属性的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#for…in"><span class="nav-number">7.1.</span> <span class="nav-text">for…in</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-keys-obj"><span class="nav-number">7.2.</span> <span class="nav-text">Object.keys(obj)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-getOwnPropertyNames-obj"><span class="nav-number">7.3.</span> <span class="nav-text">Object.getOwnPropertyNames(obj)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-getOwnPropertySymbols-obj"><span class="nav-number">7.4.</span> <span class="nav-text">Object.getOwnPropertySymbols(obj)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reflect-ownKeys-obj"><span class="nav-number">7.5.</span> <span class="nav-text">Reflect.ownKeys(obj)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proto属性，Object-setPrototypeOf-，Object-getPrototypeOf"><span class="nav-number">8.</span> <span class="nav-text">proto属性，Object.setPrototypeOf()，Object.getPrototypeOf()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#proto属性"><span class="nav-number">8.1.</span> <span class="nav-text">proto属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-setPrototypeOf"><span class="nav-number">8.2.</span> <span class="nav-text">Object.setPrototypeOf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-getPrototypeOf"><span class="nav-number">8.3.</span> <span class="nav-text">Object.getPrototypeOf()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-values-，Object-entries"><span class="nav-number">9.</span> <span class="nav-text">Object.values()，Object.entries()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-keys"><span class="nav-number">9.1.</span> <span class="nav-text">Object.keys()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-values"><span class="nav-number">9.2.</span> <span class="nav-text">Object.values()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object-entries"><span class="nav-number">9.3.</span> <span class="nav-text">Object.entries</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的扩展运算符"><span class="nav-number">10.</span> <span class="nav-text">对象的扩展运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解构赋值"><span class="nav-number">10.1.</span> <span class="nav-text">解构赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩展运算符"><span class="nav-number">10.2.</span> <span class="nav-text">扩展运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-getOwnPropertyDescriptors"><span class="nav-number">11.</span> <span class="nav-text">Object.getOwnPropertyDescriptors()</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">卓越</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"luanmingli"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

</body>
</html>
