<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavsScript,ES2015," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Proxy 和 Reflect

Proxy 概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。  
Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示">
<meta property="og:type" content="article">
<meta property="og:title" content="ES2015——12.Proxy 和 Reflect">
<meta property="og:url" content="http://yoursite.com/2016/12/13/ES2015-12_proxy_reflect/index.html">
<meta property="og:site_name" content="luanmingli">
<meta property="og:description" content="Proxy 和 Reflect

Proxy 概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。  
Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示">
<meta property="og:updated_time" content="2017-06-26T08:42:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES2015——12.Proxy 和 Reflect">
<meta name="twitter:description" content="Proxy 和 Reflect

Proxy 概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。  
Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/12/13/ES2015-12_proxy_reflect/"/>

  <title> ES2015——12.Proxy 和 Reflect | luanmingli </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?c01c0e51b835643529ad3c2911ec1bb0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">luanmingli</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">+1s</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ES2015——12.Proxy 和 Reflect
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-13T17:04:31+08:00" content="2016-12-13 17:04:31">
              2016-12-13 17:04:31
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/13/ES2015-12_proxy_reflect/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/13/ES2015-12_proxy_reflect/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="external">Proxy 和 Reflect</a></p>
</blockquote>
<h3 id="Proxy-概述"><a href="#Proxy-概述" class="headerlink" title="Proxy 概述"></a>Proxy 概述</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。  </p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<pre><code>var obj = new Proxy({}, {
  get: function (target, key, receiver) {
    console.log(`getting ${key}!`);
    return Reflect.get(target, key, receiver);
  },
  set: function (target, key, value, receiver) {
    console.log(`setting ${key}!`);
    return Reflect.set(target, key, value, receiver);
  }
});
</code></pre><p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。</p>
<pre><code>obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2
</code></pre><p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。  </p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。  </p>
<pre><code>var proxy = new Proxy(target, handler);
</code></pre><p>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。  </p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<pre><code>var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

proxy.time // 35
proxy.name // 35
proxy.title // 35
</code></pre><p>上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。  </p>
<p>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。  </p>
<p>如果handler没有设置任何拦截，那就等同于直接通向原对象。</p>
<pre><code>var target = {};
var handler = {};
var proxy = new Proxy(target, handler);
proxy.a = &apos;b&apos;;
target.a // &quot;b&quot;
</code></pre><p>上面代码中，handler是一个空对象，没有任何拦截效果，访问handler就等同于访问target。  </p>
<p>一个技巧是将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用。  </p>
<pre><code>var object = { proxy: new Proxy(target, handler) };
</code></pre><p>Proxy 实例也可以作为其他对象的原型对象。</p>
<pre><code>var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});

let obj = Object.create(proxy);
obj.time // 35
</code></pre><p>上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。  </p>
<p>同一个拦截器函数，可以设置拦截多个操作。</p>
<pre><code>var handler = {
  get: function(target, name) {
    if (name === &apos;prototype&apos;) {
      return Object.prototype;
    }
    return &apos;Hello, &apos; + name;
  },

  apply: function(target, thisBinding, args) {
    return args[0];
  },

  construct: function(target, args) {
    return {value: args[1]};
  }
};

var fproxy = new Proxy(function(x, y) {
  return x + y;
}, handler);

fproxy(1, 2) // 1
new fproxy(1,2) // {value: 2}
fproxy.prototype === Object.prototype // true
fproxy.foo // &quot;Hello, foo&quot;
</code></pre><p>下面是 Proxy 支持的拦截操作一览。  </p>
<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<h4 id="get-target-propKey-receiver"><a href="#get-target-propKey-receiver" class="headerlink" title="get(target, propKey, receiver)"></a>get(target, propKey, receiver)</h4><p>拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。  </p>
<p>最后一个参数receiver是一个对象，可选，参见下面Reflect.get的部分。</p>
<h4 id="set-target-propKey-value-receiver"><a href="#set-target-propKey-value-receiver" class="headerlink" title="set(target, propKey, value, receiver)"></a>set(target, propKey, value, receiver)</h4><p>拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</p>
<h4 id="has-target-propKey"><a href="#has-target-propKey" class="headerlink" title="has(target, propKey)"></a>has(target, propKey)</h4><p>拦截propKey in proxy的操作，以及对象的hasOwnProperty方法，返回一个布尔值。</p>
<h4 id="deleteProperty-target-propKey"><a href="#deleteProperty-target-propKey" class="headerlink" title="deleteProperty(target, propKey)"></a>deleteProperty(target, propKey)</h4><p>拦截delete proxy[propKey]的操作，返回一个布尔值。</p>
<h4 id="ownKeys-target"><a href="#ownKeys-target" class="headerlink" title="ownKeys(target)"></a>ownKeys(target)</h4><p>拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而Object.keys()仅返回对象可遍历的属性。</p>
<h4 id="getOwnPropertyDescriptor-target-propKey"><a href="#getOwnPropertyDescriptor-target-propKey" class="headerlink" title="getOwnPropertyDescriptor(target, propKey)"></a>getOwnPropertyDescriptor(target, propKey)</h4><p>拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</p>
<h4 id="defineProperty-target-propKey-propDesc"><a href="#defineProperty-target-propKey-propDesc" class="headerlink" title="defineProperty(target, propKey, propDesc)"></a>defineProperty(target, propKey, propDesc)</h4><p>拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</p>
<h4 id="preventExtensions-target"><a href="#preventExtensions-target" class="headerlink" title="preventExtensions(target)"></a>preventExtensions(target)</h4><p>拦截Object.preventExtensions(proxy)，返回一个布尔值。</p>
<h4 id="getPrototypeOf-target"><a href="#getPrototypeOf-target" class="headerlink" title="getPrototypeOf(target)"></a>getPrototypeOf(target)</h4><p>拦截Object.getPrototypeOf(proxy)，返回一个对象。</p>
<h4 id="isExtensible-target"><a href="#isExtensible-target" class="headerlink" title="isExtensible(target)"></a>isExtensible(target)</h4><p>拦截Object.isExtensible(proxy)，返回一个布尔值。</p>
<h4 id="setPrototypeOf-target-proto"><a href="#setPrototypeOf-target-proto" class="headerlink" title="setPrototypeOf(target, proto)"></a>setPrototypeOf(target, proto)</h4><p>拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。</p>
<p>如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
<h4 id="apply-target-object-args"><a href="#apply-target-object-args" class="headerlink" title="apply(target, object, args)"></a>apply(target, object, args)</h4><p>拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。</p>
<h4 id="construct-target-args"><a href="#construct-target-args" class="headerlink" title="construct(target, args)"></a>construct(target, args)</h4><p>拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</p>
<h3 id="Proxy实例的方法"><a href="#Proxy实例的方法" class="headerlink" title="Proxy实例的方法"></a>Proxy实例的方法</h3><p>下面是上面这些拦截方法的详细介绍。</p>
<h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p>get方法用于拦截某个属性的读取操作。上文已经有一个例子，下面是另一个拦截读取操作的例子。</p>
<pre><code>var person = {
  name: &quot;张三&quot;
};

var proxy = new Proxy(person, {
  get: function(target, property) {
    if (property in target) {
      return target[property];
    } else {
      throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;);
    }
  }
});

proxy.name // &quot;张三&quot;
proxy.age // 抛出一个错误
</code></pre><p>上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。  </p>
<p>get方法可以继承。</p>
<pre><code>let proto = new Proxy({}, {
  get(target, propertyKey, receiver) {
    console.log(&apos;GET &apos;+propertyKey);
    return target[propertyKey];
  }
});

let obj = Object.create(proto);
obj.xxx // &quot;GET xxx&quot;
</code></pre><p>上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。  </p>
<p>下面的例子使用get拦截，实现数组读取负数的索引。</p>
<pre><code>function createArray(...elements) {
  let handler = {
    get(target, propKey, receiver) {
      let index = Number(propKey);
      if (index &lt; 0) {
        propKey = String(target.length + index);
      }
      return Reflect.get(target, propKey, receiver);
    }
  };

  let target = [];
  target.push(...elements);
  return new Proxy(target, handler);
}

let arr = createArray(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;);
arr[-1] // c
</code></pre><p>上面代码中，数组的位置参数是-1，就会输出数组的倒数最后一个成员。  </p>
<p>利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。</p>
<pre><code>var pipe = (function () {
  return function (value) {
    var funcStack = [];
    var oproxy = new Proxy({} , {
      get : function (pipeObject, fnName) {
        if (fnName === &apos;get&apos;) {
          return funcStack.reduce(function (val, fn) {
            return fn(val);
          },value);
        }
        funcStack.push(window[fnName]);
        return oproxy;
      }
    });

    return oproxy;
  }
}());

var double = n =&gt; n * 2;
var pow    = n =&gt; n * n;
var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0;

pipe(3).double.pow.reverseInt.get; // 63
</code></pre><p>上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。  </p>
<p>下面的例子则是利用get拦截，实现一个生成各种DOM节点的通用函数dom。</p>
<pre><code>const dom = new Proxy({}, {
  get(target, property) {
    return function(attrs = {}, ...children) {
      const el = document.createElement(property);
      for (let prop of Object.keys(attrs)) {
        el.setAttribute(prop, attrs[prop]);
      }
      for (let child of children) {
        if (typeof child === &apos;string&apos;) {
          child = document.createTextNode(child);
        }
        el.appendChild(child);
      }
      return el;
    }
  }
});

const el = dom.div({},
  &apos;Hello, my name is &apos;,
  dom.a({href: &apos;//example.com&apos;}, &apos;Mark&apos;),
  &apos;. I like:&apos;,
  dom.ul({},
    dom.li({}, &apos;The web&apos;),
    dom.li({}, &apos;Food&apos;),
    dom.li({}, &apos;…actually that\&apos;s it&apos;)
  )
);

document.body.appendChild(el);
</code></pre><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p>set方法用来拦截某个属性的赋值操作。  </p>
<p>假定Person对象有一个age属性，该属性应该是一个不大于200的整数，那么可以使用Proxy保证age的属性值符合要求。</p>
<pre><code>let validator = {
  set: function(obj, prop, value) {
    if (prop === &apos;age&apos;) {
      if (!Number.isInteger(value)) {
        throw new TypeError(&apos;The age is not an integer&apos;);
      }
      if (value &gt; 200) {
        throw new RangeError(&apos;The age seems invalid&apos;);
      }
    }

    // 对于age以外的属性，直接保存
    obj[prop] = value;
  }
};

let person = new Proxy({}, validator);

person.age = 100;

person.age // 100
person.age = &apos;young&apos; // 报错
person.age = 300 // 报错
</code></pre><p>上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新DOM。  </p>
<p>有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。</p>
<pre><code>var handler = {
  get (target, key) {
    invariant(key, &apos;get&apos;);
    return target[key];
  },
  set (target, key, value) {
    invariant(key, &apos;set&apos;);
    target[key] = value;
    return true;
  }
};
function invariant (key, action) {
  if (key[0] === &apos;_&apos;) {
    throw new Error(`Invalid attempt to ${action} private &quot;${key}&quot; property`);
  }
}
var target = {};
var proxy = new Proxy(target, handler);
proxy._prop
// Error: Invalid attempt to get private &quot;_prop&quot; property
proxy._prop = &apos;c&apos;
// Error: Invalid attempt to set private &quot;_prop&quot; property
</code></pre><p>上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>apply方法拦截函数的调用、call和apply操作。</p>
<pre><code>var handler = {
  apply (target, ctx, args) {
    return Reflect.apply(...arguments);
  }
};
</code></pre><p>apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。  </p>
<p>下面是一个例子。</p>
<pre><code>var target = function () { return &apos;I am the target&apos;; };
var handler = {
  apply: function () {
    return &apos;I am the proxy&apos;;
  }
};

var p = new Proxy(target, handler);

p()
// &quot;I am the proxy&quot;
</code></pre><p>上面代码中，变量p是Proxy的实例，当它作为函数调用时（p()），就会被apply方法拦截，返回一个字符串。  </p>
<p>下面是另外一个例子。</p>
<pre><code>var twice = {
  apply (target, ctx, args) {
    return Reflect.apply(...arguments) * 2;
  }
};
function sum (left, right) {
  return left + right;
};
var proxy = new Proxy(sum, twice);
proxy(1, 2) // 6
proxy.call(null, 5, 6) // 22
proxy.apply(null, [7, 8]) // 30
</code></pre><p>上面代码中，每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。  </p>
<p>另外，直接调用Reflect.apply方法，也会被拦截。</p>
<pre><code>Reflect.apply(proxy, null, [9, 10]) // 38
</code></pre><h4 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h4><p>has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。  </p>
<p>下面的例子使用has方法隐藏某些属性，不被in运算符发现。</p>
<pre><code>var handler = {
  has (target, key) {
    if (key[0] === &apos;_&apos;) {
      return false;
    }
    return key in target;
  }
};
var target = { _prop: &apos;foo&apos;, prop: &apos;foo&apos; };
var proxy = new Proxy(target, handler);
&apos;_prop&apos; in proxy // false
</code></pre><p>上面代码中，如果原对象的属性名的第一个字符是下划线，proxy.has就会返回false，从而不会被in运算符发现。  </p>
<p>如果原对象不可配置或者禁止扩展，这时has拦截会报错。</p>
<pre><code>var obj = { a: 10 };
Object.preventExtensions(obj);
var p = new Proxy(obj, {
  has: function(target, prop) {
    return false;
  }
});

&apos;a&apos; in p // TypeError is thrown
</code></pre><p>上面代码中，obj对象禁止扩展，结果使用has拦截就会报错。  </p>
<p>值得注意的是，has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。  </p>
<p>另外，虽然for…in循环也用到了in运算符，但是has拦截对for…in循环不生效。</p>
<pre><code>let stu1 = {name: &apos;张三&apos;, score: 59};
let stu2 = {name: &apos;李四&apos;, score: 99};

let handler = {
  has(target, prop) {
    if (prop === &apos;score&apos; &amp;&amp; target[prop] &lt; 60) {
      console.log(`${target.name} 不及格`);
      return false;
    }
    return prop in target;
  }
}

let oproxy1 = new Proxy(stu1, handler);
let oproxy2 = new Proxy(stu2, handler);

&apos;score&apos; in oproxy1
// 张三 不及格
// false

&apos;score&apos; in oproxy2
// true

for (let a in oproxy1) {
  console.log(oproxy1[a]);
}
// 张三
// 59

for (let b in oproxy2) {
  console.log(oproxy2[b]);
}
// 李四
// 99
</code></pre><p>上面代码中，has拦截只对in循环生效，对for…in循环不生效，导致不符合要求的属性没有被排除在for…in循环之外。</p>
<h4 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h4><p>construct方法用于拦截new命令，下面是拦截对象的写法。</p>
<pre><code>var handler = {
  construct (target, args, newTarget) {
    return new target(...args);
  }
};
</code></pre><p>construct方法可以接受两个参数。</p>
<ul>
<li>target: 目标对象</li>
<li>args：构建函数的参数对象</li>
</ul>
<p>下面是一个例子。</p>
<pre><code>var p = new Proxy(function() {}, {
  construct: function(target, args) {
    console.log(&apos;called: &apos; + args.join(&apos;, &apos;));
    return { value: args[0] * 10 };
  }
});

new p(1).value
// &quot;called: 1&quot;
// 10
</code></pre><p>construct方法返回的必须是一个对象，否则会报错。</p>
<pre><code>var p = new Proxy(function() {}, {
  construct: function(target, argumentsList) {
    return 1;
  }
});

new p() // 报错
</code></pre><h4 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h4><p>deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</p>
<pre><code>var handler = {
  deleteProperty (target, key) {
    invariant(key, &apos;delete&apos;);
    return true;
  }
};
function invariant (key, action) {
  if (key[0] === &apos;_&apos;) {
    throw new Error(`Invalid attempt to ${action} private &quot;${key}&quot; property`);
  }
}

var target = { _prop: &apos;foo&apos; };
var proxy = new Proxy(target, handler);
delete proxy._prop
// Error: Invalid attempt to delete private &quot;_prop&quot; property
</code></pre><p>上面代码中，deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。</p>
<h4 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h4><p>defineProperty方法拦截了Object.defineProperty操作。</p>
<pre><code>var handler = {
  defineProperty (target, key, descriptor) {
    return false;
  }
};
var target = {};
var proxy = new Proxy(target, handler);
proxy.foo = &apos;bar&apos;
// TypeError: proxy defineProperty handler returned false for property &apos;&quot;foo&quot;&apos;
</code></pre><p>上面代码中，defineProperty方法返回false，导致添加新属性会抛出错误。</p>
<h4 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h4><p>getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor，返回一个属性描述对象或者undefined。</p>
<pre><code>var handler = {
  getOwnPropertyDescriptor (target, key) {
    if (key[0] === &apos;_&apos;) {
      return;
    }
    return Object.getOwnPropertyDescriptor(target, key);
  }
};
var target = { _foo: &apos;bar&apos;, baz: &apos;tar&apos; };
var proxy = new Proxy(target, handler);
Object.getOwnPropertyDescriptor(proxy, &apos;wat&apos;)
// undefined
Object.getOwnPropertyDescriptor(proxy, &apos;_foo&apos;)
// undefined
Object.getOwnPropertyDescriptor(proxy, &apos;baz&apos;)
// { value: &apos;tar&apos;, writable: true, enumerable: true, configurable: true }
</code></pre><p>上面代码中，handler.getOwnPropertyDescriptor方法对于第一个字符为下划线的属性名会返回undefined。</p>
<h4 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h4><p>getPrototypeOf方法主要用来拦截Object.getPrototypeOf()运算符，以及其他一些操作。</p>
<ul>
<li>Object.prototype.<strong>proto</strong></li>
<li>Object.prototype.isPrototypeOf()</li>
<li>Object.getPrototypeOf()</li>
<li>Reflect.getPrototypeOf()</li>
<li>instanceof运算符</li>
</ul>
<p>下面是一个例子。</p>
<pre><code>var proto = {};
var p = new Proxy({}, {
  getPrototypeOf(target) {
    return proto;
  }
});
Object.getPrototypeOf(p) === proto // true
</code></pre><p>上面代码中，getPrototypeOf方法拦截Object.getPrototypeOf()，返回proto对象。</p>
<h4 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h4><p>isExtensible方法拦截Object.isExtensible操作。</p>
<pre><code>var p = new Proxy({}, {
  isExtensible: function(target) {
    console.log(&quot;called&quot;);
    return true;
  }
});

Object.isExtensible(p)
// &quot;called&quot;
// true
</code></pre><p>上面代码设置了isExtensible方法，在调用Object.isExtensible时会输出called。  </p>
<p>这个方法有一个强限制，如果不能满足下面的条件，就会抛出错误。</p>
<pre><code>Object.isExtensible(proxy) === Object.isExtensible(target)
</code></pre><p>下面是一个例子。</p>
<pre><code>var p = new Proxy({}, {
  isExtensible: function(target) {
    return false;
  }
});

Object.isExtensible(p) // 报错
</code></pre><h4 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h4><p>ownKeys方法用来拦截Object.keys()操作。</p>
<pre><code>let target = {};

let handler = {
  ownKeys(target) {
    return [&apos;hello&apos;, &apos;world&apos;];
  }
};

let proxy = new Proxy(target, handler);

Object.keys(proxy)
// [ &apos;hello&apos;, &apos;world&apos; ]
</code></pre><p>上面代码拦截了对于target对象的Object.keys()操作，返回预先设定的数组。  </p>
<p>下面的例子是拦截第一个字符为下划线的属性名。</p>
<pre><code>let target = {
  _bar: &apos;foo&apos;,
  _prop: &apos;bar&apos;,
  prop: &apos;baz&apos;
};

let handler = {
  ownKeys (target) {
    return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &apos;_&apos;);
  }
};

let proxy = new Proxy(target, handler);
for (let key of Object.keys(proxy)) {
  console.log(target[key]);
}
// &quot;baz&quot;
</code></pre><h4 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h4><p>preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值。  </p>
<p>这个方法有一个限制，只有当Object.isExtensible(proxy)为false（即不可扩展）时，proxy.preventExtensions才能返回true，否则会报错。</p>
<pre><code>var p = new Proxy({}, {
  preventExtensions: function(target) {
    return true;
  }
});

Object.preventExtensions(p) // 报错
</code></pre><p>上面代码中，proxy.preventExtensions方法返回true，但这时Object.isExtensible(proxy)会返回true，因此报错。  </p>
<p>为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensions。</p>
<pre><code>var p = new Proxy({}, {
  preventExtensions: function(target) {
    console.log(&quot;called&quot;);
    Object.preventExtensions(target);
    return true;
  }
});

Object.preventExtensions(p)
// &quot;called&quot;
// true
</code></pre><h4 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h4><p>setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。  </p>
<p>下面是一个例子。</p>
<pre><code>var handler = {
  setPrototypeOf (target, proto) {
    throw new Error(&apos;Changing the prototype is forbidden&apos;);
  }
};
var proto = {};
var target = function () {};
var proxy = new Proxy(target, handler);
proxy.setPrototypeOf(proxy, proto);
// Error: Changing the prototype is forbidden
</code></pre><p>上面代码中，只要修改target的原型对象，就会报错。</p>
<h3 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h3><p>Proxy.revocable方法返回一个可取消的Proxy实例。</p>
<pre><code>let target = {};
let handler = {};

let {proxy, revoke} = Proxy.revocable(target, handler);

proxy.foo = 123;
proxy.foo // 123

revoke();
proxy.foo // TypeError: Revoked
</code></pre><p>Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。</p>
<h3 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h3><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。</p>
<pre><code>const target = {
  m: function () {
    console.log(this === proxy);
  }
};
const handler = {};

const proxy = new Proxy(target, handler);

target.m() // false
proxy.m()  // true
</code></pre><p>上面代码中，一旦proxy代理target.m，后者内部的this就是指向proxy，而不是target。  </p>
<p>下面是一个例子，由于this指向的变化，导致 Proxy 无法代理目标对象。</p>
<pre><code>const _name = new WeakMap();

class Person {
  constructor(name) {
    _name.set(this, name);
  }
  get name() {
    return _name.get(this);
  }
}

const jane = new Person(&apos;Jane&apos;);
jane.name // &apos;Jane&apos;

const proxy = new Proxy(jane, {});
proxy.name // undefined
</code></pre><p>上面代码中，目标对象jane的name属性，实际保存在外部WeakMap对象_name上面，通过this键区分。由于通过proxy.name访问时，this指向proxy，导致无法取到值，所以返回undefined。  </p>
<p>此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。</p>
<pre><code>const target = new Date();
const handler = {};
const proxy = new Proxy(target, handler);

proxy.getDate();
// TypeError: this is not a Date object.
</code></pre><p>上面代码中，getDate方法只能在Date对象实例上面拿到，如果this不是Date对象实例就会报错。这时，this绑定原始对象，就可以解决这个问题。</p>
<pre><code>const target = new Date(&apos;2015-01-01&apos;);
const handler = {
  get(target, prop) {
    if (prop === &apos;getDate&apos;) {
      return target.getDate.bind(target);
    }
    return Reflect.get(target, prop);
  }
};
const proxy = new Proxy(target, handler);

proxy.getDate() // 1
</code></pre><h3 id="Reflect概述"><a href="#Reflect概述" class="headerlink" title="Reflect概述"></a>Reflect概述</h3><p>Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象的设计目的有这样几个。  </p>
<ol>
<li>将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。</li>
<li><p>修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</p>
<pre><code>// 老写法
try {
  Object.defineProperty(target, property, attributes);
  // success
} catch (e) {
  // failure
}

// 新写法
if (Reflect.defineProperty(target, property, attributes)) {
  // success
} else {
  // failure
}
</code></pre></li>
<li><p>让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</p>
<pre><code>// 老写法
&apos;assign&apos; in Object // true

// 新写法
Reflect.has(Object, &apos;assign&apos;) // true
</code></pre></li>
<li><p>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</p>
<pre><code>Proxy(target, {
  set: function(target, name, value, receiver) {
    var success = Reflect.set(target,name, value, receiver);
    if (success) {
      log(&apos;property &apos; + name + &apos; on &apos; + target + &apos; set to &apos; + value);
    }
    return success;
  }
});
</code></pre><p> 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，然后再部署额外的功能。  </p>
<p> 下面是另一个例子。</p>
<pre><code>var loggedObj = new Proxy(obj, {
  get(target, name) {
    console.log(&apos;get&apos;, target, name);
    return Reflect.get(target, name);
  },
  deleteProperty(target, name) {
    console.log(&apos;delete&apos; + name);
    return Reflect.deleteProperty(target, name);
  },
  has(target, name) {
    console.log(&apos;has&apos; + name);
    return Reflect.has(target, name);
  }
});
</code></pre><p> 上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。  </p>
<p> 有了Reflect对象以后，很多操作会更易读。</p>
<pre><code>// 老写法
Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1

// 新写法
Reflect.apply(Math.floor, undefined, [1.75]) // 1
</code></pre></li>
</ol>
<h3 id="Reflect对象的方法"><a href="#Reflect对象的方法" class="headerlink" title="Reflect对象的方法"></a>Reflect对象的方法</h3><p>Reflect对象的方法清单如下，共13个。</p>
<ul>
<li>Reflect.apply(target,thisArg,args)</li>
<li>Reflect.construct(target,args)</li>
<li>Reflect.get(target,name,receiver)</li>
<li>Reflect.set(target,name,value,receiver)</li>
<li>Reflect.defineProperty(target,name,desc)</li>
<li>Reflect.deleteProperty(target,name)</li>
<li>Reflect.has(target,name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)</li>
</ul>
<p>上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对其中几个方法的解释。</p>
<h4 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h4><p>查找并返回target对象的name属性，如果没有该属性，则返回undefined。  </p>
<p>如果name属性部署了读取函数，则读取函数的this绑定receiver。</p>
<pre><code>var obj = {
  get foo() { return this.bar(); },
  bar: function() { ... }
};

// 下面语句会让 this.bar()
// 变成调用 wrapper.bar()
Reflect.get(obj, &quot;foo&quot;, wrapper);
</code></pre><h4 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h4><p>设置target对象的name属性等于value。如果name属性设置了赋值函数，则赋值函数的this绑定receiver。</p>
<h4 id="Reflect-has-obj-name"><a href="#Reflect-has-obj-name" class="headerlink" title="Reflect.has(obj, name)"></a>Reflect.has(obj, name)</h4><p>等同于name in obj。</p>
<h4 id="Reflect-deleteProperty-obj-name"><a href="#Reflect-deleteProperty-obj-name" class="headerlink" title="Reflect.deleteProperty(obj, name)"></a>Reflect.deleteProperty(obj, name)</h4><p>等同于delete obj[name]。</p>
<h4 id="Reflect-construct-target-args"><a href="#Reflect-construct-target-args" class="headerlink" title="Reflect.construct(target, args)"></a>Reflect.construct(target, args)</h4><p>等同于new target(…args)，这提供了一种不使用new，来调用构造函数的方法。</p>
<h4 id="Reflect-getPrototypeOf-obj"><a href="#Reflect-getPrototypeOf-obj" class="headerlink" title="Reflect.getPrototypeOf(obj)"></a>Reflect.getPrototypeOf(obj)</h4><p>读取对象的<strong>proto</strong>属性，对应Object.getPrototypeOf(obj)。</p>
<h4 id="Reflect-setPrototypeOf-obj-newProto"><a href="#Reflect-setPrototypeOf-obj-newProto" class="headerlink" title="Reflect.setPrototypeOf(obj, newProto)"></a>Reflect.setPrototypeOf(obj, newProto)</h4><p>设置对象的<strong>proto</strong>属性，对应Object.setPrototypeOf(obj, newProto)。</p>
<h4 id="Reflect-apply-fun-thisArg-args"><a href="#Reflect-apply-fun-thisArg-args" class="headerlink" title="Reflect.apply(fun,thisArg,args)"></a>Reflect.apply(fun,thisArg,args)</h4><p>等同于Function.prototype.apply.call(fun,thisArg,args)。一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。  </p>
<p>另外，需要注意的是，Reflect.set()、Reflect.defineProperty()、Reflect.freeze()、Reflect.seal()和Reflect.preventExtensions()返回一个布尔值，表示操作是否成功。它们对应的Object方法，失败时都会抛出错误。  </p>
<pre><code>// 失败时抛出错误
Object.defineProperty(obj, name, desc);
// 失败时返回false
Reflect.defineProperty(obj, name, desc);
</code></pre><p>上面代码中，Reflect.defineProperty方法的作用与Object.defineProperty是一样的，都是为对象定义一个属性。但是，Reflect.defineProperty方法失败时，不会抛出错误，只会返回false。  </p>
<h3 id="实例：使用-Proxy-实现观察者模式"><a href="#实例：使用-Proxy-实现观察者模式" class="headerlink" title="实例：使用 Proxy 实现观察者模式"></a>实例：使用 Proxy 实现观察者模式</h3><p>观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。</p>
<pre><code>const person = observable({
  name: &apos;张三&apos;,
  age: 20
});

function print() {
  console.log(`${person.name}, ${person.age}`)
}

observe(print);
person.name = &apos;李四&apos;;
// 输出
// 李四, 20
</code></pre><p>上面代码中，数据对象person是观察目标，函数print是观察者。一旦数据对象发生变化，print就会自动执行。  </p>
<p>下面，使用 Proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。思路是observable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。</p>
<pre><code>const queuedObservers = new Set();

const observe = fn =&gt; queuedObservers.add(fn);
const observable = obj =&gt; new Proxy(obj, {set});

function set(target, key, value, receiver) {
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer =&gt; observer());
  return result;
}
</code></pre><p>上面代码中，先定义了一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://www.luanmingli.com/static/image/wechat-reward-image.png" alt="LuanMingli WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="http://www.luanmingli.com/static/image/alipay-reward-image.png" alt="LuanMingli Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavsScript/" rel="tag">#JavsScript</a>
          
            <a href="/tags/ES2015/" rel="tag">#ES2015</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/13/ES2015-11_set_map/" rel="next" title="ES2015——11.Set和Map数据结构">
                <i class="fa fa-chevron-left"></i> ES2015——11.Set和Map数据结构
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/13/ES2015-13_iterator_for_of/" rel="prev" title="ES2015——13.Iterator和for...of循环">
                ES2015——13.Iterator和for...of循环 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/12/13/ES2015-12_proxy_reflect/"
           data-title="ES2015——12.Proxy 和 Reflect" data-url="http://yoursite.com/2016/12/13/ES2015-12_proxy_reflect/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://www.luanmingli.com/static/image/head.png"
               alt="LuanMingli" />
          <p class="site-author-name" itemprop="name">LuanMingli</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">125</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">67</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://github.com/Lmingli" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy-概述"><span class="nav-number">1.</span> <span class="nav-text">Proxy 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#get-target-propKey-receiver"><span class="nav-number">1.1.</span> <span class="nav-text">get(target, propKey, receiver)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set-target-propKey-value-receiver"><span class="nav-number">1.2.</span> <span class="nav-text">set(target, propKey, value, receiver)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#has-target-propKey"><span class="nav-number">1.3.</span> <span class="nav-text">has(target, propKey)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deleteProperty-target-propKey"><span class="nav-number">1.4.</span> <span class="nav-text">deleteProperty(target, propKey)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ownKeys-target"><span class="nav-number">1.5.</span> <span class="nav-text">ownKeys(target)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getOwnPropertyDescriptor-target-propKey"><span class="nav-number">1.6.</span> <span class="nav-text">getOwnPropertyDescriptor(target, propKey)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defineProperty-target-propKey-propDesc"><span class="nav-number">1.7.</span> <span class="nav-text">defineProperty(target, propKey, propDesc)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#preventExtensions-target"><span class="nav-number">1.8.</span> <span class="nav-text">preventExtensions(target)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getPrototypeOf-target"><span class="nav-number">1.9.</span> <span class="nav-text">getPrototypeOf(target)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#isExtensible-target"><span class="nav-number">1.10.</span> <span class="nav-text">isExtensible(target)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setPrototypeOf-target-proto"><span class="nav-number">1.11.</span> <span class="nav-text">setPrototypeOf(target, proto)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#apply-target-object-args"><span class="nav-number">1.12.</span> <span class="nav-text">apply(target, object, args)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#construct-target-args"><span class="nav-number">1.13.</span> <span class="nav-text">construct(target, args)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy实例的方法"><span class="nav-number">2.</span> <span class="nav-text">Proxy实例的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#get"><span class="nav-number">2.1.</span> <span class="nav-text">get()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set"><span class="nav-number">2.2.</span> <span class="nav-text">set()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#apply"><span class="nav-number">2.3.</span> <span class="nav-text">apply()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#has"><span class="nav-number">2.4.</span> <span class="nav-text">has()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#construct"><span class="nav-number">2.5.</span> <span class="nav-text">construct()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#deleteProperty"><span class="nav-number">2.6.</span> <span class="nav-text">deleteProperty()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#defineProperty"><span class="nav-number">2.7.</span> <span class="nav-text">defineProperty()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getOwnPropertyDescriptor"><span class="nav-number">2.8.</span> <span class="nav-text">getOwnPropertyDescriptor()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#getPrototypeOf"><span class="nav-number">2.9.</span> <span class="nav-text">getPrototypeOf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#isExtensible"><span class="nav-number">2.10.</span> <span class="nav-text">isExtensible()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ownKeys"><span class="nav-number">2.11.</span> <span class="nav-text">ownKeys()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#preventExtensions"><span class="nav-number">2.12.</span> <span class="nav-text">preventExtensions()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setPrototypeOf"><span class="nav-number">2.13.</span> <span class="nav-text">setPrototypeOf()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy-revocable"><span class="nav-number">3.</span> <span class="nav-text">Proxy.revocable()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this-问题"><span class="nav-number">4.</span> <span class="nav-text">this 问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect概述"><span class="nav-number">5.</span> <span class="nav-text">Reflect概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reflect对象的方法"><span class="nav-number">6.</span> <span class="nav-text">Reflect对象的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Reflect-get-target-name-receiver"><span class="nav-number">6.1.</span> <span class="nav-text">Reflect.get(target, name, receiver)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reflect-set-target-name-value-receiver"><span class="nav-number">6.2.</span> <span class="nav-text">Reflect.set(target, name, value, receiver)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reflect-has-obj-name"><span class="nav-number">6.3.</span> <span class="nav-text">Reflect.has(obj, name)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reflect-deleteProperty-obj-name"><span class="nav-number">6.4.</span> <span class="nav-text">Reflect.deleteProperty(obj, name)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reflect-construct-target-args"><span class="nav-number">6.5.</span> <span class="nav-text">Reflect.construct(target, args)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reflect-getPrototypeOf-obj"><span class="nav-number">6.6.</span> <span class="nav-text">Reflect.getPrototypeOf(obj)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reflect-setPrototypeOf-obj-newProto"><span class="nav-number">6.7.</span> <span class="nav-text">Reflect.setPrototypeOf(obj, newProto)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reflect-apply-fun-thisArg-args"><span class="nav-number">6.8.</span> <span class="nav-text">Reflect.apply(fun,thisArg,args)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例：使用-Proxy-实现观察者模式"><span class="nav-number">7.</span> <span class="nav-text">实例：使用 Proxy 实现观察者模式</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LuanMingli</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"luanmingli"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

</body>
</html>
