<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="JavsScript,vuejs," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="什么是组件？组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。  
使用组件注册之前说过，我们可以通过以下方式创建一个 Vue 实例：
new Vue({
  el: &amp;apos;#so">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue.js——10.表单控件绑定">
<meta property="og:url" content="http://yoursite.com/2017/01/21/vuejs-10/index.html">
<meta property="og:site_name" content="zhuoyue">
<meta property="og:description" content="什么是组件？组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。  
使用组件注册之前说过，我们可以通过以下方式创建一个 Vue 实例：
new Vue({
  el: &amp;apos;#so">
<meta property="og:updated_time" content="2017-06-26T08:42:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vue.js——10.表单控件绑定">
<meta name="twitter:description" content="什么是组件？组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。  
使用组件注册之前说过，我们可以通过以下方式创建一个 Vue 实例：
new Vue({
  el: &amp;apos;#so">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2017/01/21/vuejs-10/"/>

  <title> Vue.js——10.表单控件绑定 | zhuoyue </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?c01c0e51b835643529ad3c2911ec1bb0";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">zhuoyue</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">+1s</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Vue.js——10.表单控件绑定
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-01-21T13:18:42+08:00" content="2017-01-21 13:18:42">
              2017-01-21 13:18:42
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/01/21/vuejs-10/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/01/21/vuejs-10/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p><a href="http://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="external"></a></p>
</blockquote>
<h3 id="什么是组件？"><a href="#什么是组件？" class="headerlink" title="什么是组件？"></a>什么是组件？</h3><p>组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。  </p>
<h3 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>之前说过，我们可以通过以下方式创建一个 Vue 实例：</p>
<pre><code>new Vue({
  el: &apos;#some-element&apos;,
  // 选项
})
</code></pre><p>要注册一个全局组件，你可以使用 Vue.component(tagName, options)。 例如：</p>
<pre><code>Vue.component(&apos;my-component&apos;, {
  // 选项
})
</code></pre><p>对于自定义标签名，Vue.js 不强制要求遵循 W3C规则 （小写，并且包含一个短杠），尽管遵循这个规则比较好。  </p>
<p>组件在注册之后，便可以在父实例的模块中以自定义元素 <my-component></my-component> 的形式使用。要确保在初始化根实例 之前 注册了组件： </p>
<pre><code>&lt;div id=&quot;example&quot;&gt;
  &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
// 注册
Vue.component(&apos;my-component&apos;, {
  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;
})
// 创建根实例
new Vue({
  el: &apos;#example&apos;
})
</code></pre><p>渲染为：</p>
<pre><code>&lt;div id=&quot;example&quot;&gt;
  &lt;div&gt;A custom component!&lt;/div&gt;
&lt;/div&gt;
A custom component!
</code></pre><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>不必在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用：</p>
<pre><code>var Child = {
  template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;
}
new Vue({
  // ...
  components: {
    // &lt;my-component&gt; 将只在父模板可用
    &apos;my-component&apos;: Child
  }
})
</code></pre><p>这种封装也适用于其它可注册的 Vue 功能，如指令。</p>
<h4 id="DOM-模版解析说明"><a href="#DOM-模版解析说明" class="headerlink" title="DOM 模版解析说明"></a>DOM 模版解析说明</h4><p>当使用 DOM 作为模版时（例如，将 el 选项挂载到一个已存在的元素上）, 你会受到 HTML 的一些限制，因为 Vue 只有在浏览器解析和标准化 HTML 后才能获取模版内容。尤其像这些元素 <ul> ， <ol>， <table> ， <select> 限制了能被它包裹的元素， <option> 只能出现在其它元素内部。  </option></select></table></ol></ul></p>
<p>在自定义组件中使用这些受限制的元素时会导致一些问题，例如：</p>
<pre><code>&lt;table&gt;
  &lt;my-row&gt;...&lt;/my-row&gt;
&lt;/table&gt;
</code></pre><p>自定义组件 <my-row> 被认为是无效的内容，因此在渲染的时候会导致错误。变通的方案是使用特殊的 is 属性：</my-row></p>
<pre><code>&lt;table&gt;
  &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre><p>应当注意，如果您使用来自以下来源之一的字符串模板，这些限制将不适用：</p>
<ul>
<li><script type="text/x-template"></li>
<li>JavaScript内联模版字符串</li>
<li>.vue 组件</li>
</ul>
<p>因此，有必要的话请使用字符串模版。</p>
<h4 id="data-必须是函数"><a href="#data-必须是函数" class="headerlink" title="data 必须是函数"></a>data 必须是函数</h4><p>使用组件时，大多数可以传入到 Vue 构造器中的选项可以在注册组件时使用，有一个例外： data 必须是函数。 实际上，如果你这么做：</p>
<pre><code>Vue.component(&apos;my-component&apos;, {
  template: &apos;&lt;span&gt;{{ message }}&lt;/span&gt;&apos;,
  data: {
    message: &apos;hello&apos;
  }
})
</code></pre><p>那么 Vue 会在控制台发出警告，告诉你在组件中 data 必须是一个函数。最好理解这种规则的存在意义。</p>
<pre><code>&lt;div id=&quot;example-2&quot;&gt;
  &lt;simple-counter&gt;&lt;/simple-counter&gt;
  &lt;simple-counter&gt;&lt;/simple-counter&gt;
  &lt;simple-counter&gt;&lt;/simple-counter&gt;
&lt;/div&gt;
var data = { counter: 0 }
Vue.component(&apos;simple-counter&apos;, {
  template: &apos;&lt;button v-on:click=&quot;counter += 1&quot;&gt;{{ counter }}&lt;/button&gt;&apos;,
  // data 是一个函数，因此 Vue 不会警告，
  // 但是我们为每一个组件返回了同一个对象引用
  data: function () {
    return data
  }
})
new Vue({
  el: &apos;#example-2&apos;
})
0 0 0
</code></pre><p>由于这三个组件共享了同一个 data ， 因此增加一个 counter 会影响所有组件！我们可以通过为每个组件返回新的 data 对象来解决这个问题：</p>
<pre><code>data: function () {
  return {
    counter: 0
  }
}
</code></pre><p>现在每个 counter 都有它自己内部的状态了：</p>
<pre><code>0 0 0
</code></pre><h4 id="构成组件"><a href="#构成组件" class="headerlink" title="构成组件"></a>构成组件</h4><p>组件意味着协同工作，通常父子组件会是这样的关系：组件 A 在它的模版中使用了组件 B 。它们之间必然需要相互通信：父组件要给子组件传递数据，子组件需要将它内部发生的事情告知给父组件。然而，在一个良好定义的接口中尽可能将父子组件解耦是很重要的。这保证了每个组件可以在相对隔离的环境中书写和理解，也大幅提高了组件的可维护性和可重用性。  </p>
<p>在 Vue.js 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。看看它们是怎么工作的。</p>
<p><img src="http://cn.vuejs.org/images/props-events.png" alt=""></p>
<h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><h3 id="使用-Prop-传递数据"><a href="#使用-Prop-传递数据" class="headerlink" title="使用 Prop 传递数据"></a>使用 Prop 传递数据</h3><p>组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。  </p>
<p>prop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 props 选项声明 “prop”：</p>
<pre><code>Vue.component(&apos;child&apos;, {
  // 声明 props
  props: [&apos;message&apos;],
  // 就像 data 一样，prop 可以用在模板内
  // 同样也可以在 vm 实例中像 “this.message” 这样使用
  template: &apos;&lt;span&gt;{{ message }}&lt;/span&gt;&apos;
})
</code></pre><p>然后向它传入一个普通字符串：</p>
<pre><code>&lt;child message=&quot;hello!&quot;&gt;&lt;/child&gt;
</code></pre><p>结果：</p>
<pre><code>hello!
</code></pre><h4 id="camelCase-vs-kebab-case"><a href="#camelCase-vs-kebab-case" class="headerlink" title="camelCase vs. kebab-case"></a>camelCase vs. kebab-case</h4><p>HTML 特性不区分大小写。当使用非字符串模版时，prop的名字形式会从 camelCase 转为 kebab-case（短横线隔开）：</p>
<pre><code>Vue.component(&apos;child&apos;, {
  // camelCase in JavaScript
  props: [&apos;myMessage&apos;],
  template: &apos;&lt;span&gt;{{ myMessage }}&lt;/span&gt;&apos;
})
&lt;!-- kebab-case in HTML --&gt;
&lt;child my-message=&quot;hello!&quot;&gt;&lt;/child&gt;
</code></pre><p>再次说明，如果你使用字符串模版，不用在意这些限制。</p>
<h4 id="动态-Prop"><a href="#动态-Prop" class="headerlink" title="动态 Prop"></a>动态 Prop</h4><p>类似于用 v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件：</p>
<pre><code>&lt;div&gt;
  &lt;input v-model=&quot;parentMsg&quot;&gt;
  &lt;br&gt;
  &lt;child v-bind:my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;
&lt;/div&gt;
</code></pre><p>使用 v-bind 的缩写语法通常更简单：</p>
<pre><code>&lt;child :my-message=&quot;parentMsg&quot;&gt;&lt;/child&gt;
结果：

Message from parent
</code></pre><h4 id="字面量语法-vs-动态语法"><a href="#字面量语法-vs-动态语法" class="headerlink" title="字面量语法 vs 动态语法"></a>字面量语法 vs 动态语法</h4><p>初学者常犯的一个错误是使用字面量语法传递数值：</p>
<pre><code>&lt;!-- 传递了一个字符串&quot;1&quot; --&gt;
&lt;comp some-prop=&quot;1&quot;&gt;&lt;/comp&gt;
</code></pre><p>因为它是一个字面 prop ，它的值以字符串 “1” 而不是以实际的数字传下去。如果想传递一个实际的 JavaScript 数字，需要使用 v-bind ，从而让它的值被当作 JavaScript 表达式计算：</p>
<pre><code>&lt;!-- 传递实际的数字 --&gt;
&lt;comp v-bind:some-prop=&quot;1&quot;&gt;&lt;/comp&gt;
</code></pre><h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。  </p>
<p>另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。  </p>
<p>通常有两种改变 prop 的情况：  </p>
<p>1.prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用；<br>1.prop 作为需要被转变的原始值传入。</p>
<p>更确切的说这两种情况是：</p>
<ol>
<li><p>定义一个局部 data 属性，并将 prop 的初始值作为局部数据的初始值。</p>
<pre><code>props: [&apos;initialCounter&apos;],
data: function () {
  return { counter: this.initialCounter }
}
</code></pre></li>
<li><p>定义一个 computed 属性，此属性从 prop 的值计算得出。</p>
<pre><code>props: [&apos;size&apos;],
computed: {
  normalizedSize: function () {
    return this.size.trim().toLowerCase()
  }
}
</code></pre></li>
</ol>
<p>注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。</p>
<h4 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h4><p>组件可以为 props 指定验证要求。如果未指定验证要求，Vue 会发出警告。当组件给其他人使用时这很有用。  </p>
<p>prop 是一个对象而不是字符串数组时，它包含验证要求：</p>
<pre><code>Vue.component(&apos;example&apos;, {
  props: {
    // 基础类型检测 （`null` 意思是任何类型都可以）
    propA: Number,
    // 多种类型
    propB: [String, Number],
    // 必传且是字符串
    propC: {
      type: String,
      required: true
    },
    // 数字，有默认值
    propD: {
      type: Number,
      default: 100
    },
    // 数组／对象的默认值应当由一个工厂函数返回
    propE: {
      type: Object,
      default: function () {
        return { message: &apos;hello&apos; }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function (value) {
        return value &gt; 10
      }
    }
  }
})
</code></pre><p>type 可以是下面原生构造器：</p>
<ol>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Function</li>
<li>Object</li>
<li>Array</li>
</ol>
<p>type 也可以是一个自定义构造器，使用 instanceof 检测。<br>当 prop 验证失败了，如果使用的是开发版本会抛出一条警告。</p>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>我们知道，父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！  </p>
<h4 id="使用-v-on-绑定自定义事件"><a href="#使用-v-on-绑定自定义事件" class="headerlink" title="使用 v-on 绑定自定义事件"></a>使用 v-on 绑定自定义事件</h4><p>每个 Vue 实例都实现了事件接口(Events interface)，即：</p>
<ul>
<li>使用 $on(eventName) 监听事件</li>
<li>使用 $emit(eventName) 触发事件</li>
</ul>
<p>Vue的事件系统分离自浏览器的EventTarget API。尽管它们的运行类似，但是<code>$on</code> 和 <code>$emit</code> 不是addEventListener 和 dispatchEvent 的别名。  </p>
<p>另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。  </p>
<p>下面是一个例子：</p>
<pre><code>&lt;div id=&quot;counter-event-example&quot;&gt;
  &lt;p&gt;{{ total }}&lt;/p&gt;
  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;
  &lt;button-counter v-on:increment=&quot;incrementTotal&quot;&gt;&lt;/button-counter&gt;
&lt;/div&gt;
Vue.component(&apos;button-counter&apos;, {
  template: &apos;&lt;button v-on:click=&quot;increment&quot;&gt;{{ counter }}&lt;/button&gt;&apos;,
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    increment: function () {
      this.counter += 1
      this.$emit(&apos;increment&apos;)
    }
  },
})
new Vue({
  el: &apos;#counter-event-example&apos;,
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
0
0 0
</code></pre><p>在本例中，子组件已经和它外部完全解耦了。它所做的只是触发一个父组件关心的内部事件。  </p>
<p>给组件绑定原生事件</p>
<p>有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 .native 修饰 v-on 。例如：</p>
<pre><code>&lt;my-component v-on:click.native=&quot;doTheThing&quot;&gt;&lt;/my-component&gt;
</code></pre><h4 id="使用自定义事件的表单输入组件"><a href="#使用自定义事件的表单输入组件" class="headerlink" title="使用自定义事件的表单输入组件"></a>使用自定义事件的表单输入组件</h4><p>自定义事件也可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。牢记：</p>
<pre><code>&lt;input v-model=&quot;something&quot;&gt;
</code></pre><p>仅仅是一个语法糖：  </p>
<pre><code>&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;
</code></pre><p>所以在组件中使用时，它相当于下面的简写：</p>
<pre><code>&lt;custom-input v-bind:value=&quot;something&quot; v-on:input=&quot;something = arguments[0]&quot;&gt;&lt;/custom-input&gt;
</code></pre><p>所以要让组件的 v-model 生效，它必须：</p>
<ul>
<li>接受一个 value 属性</li>
<li>在有新的 value 时触发 input 事件</li>
</ul>
<p>一个非常简单的货币输入：</p>
<pre><code>&lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currency-input&gt;
Vue.component(&apos;currency-input&apos;, {
  template: &apos;\
    &lt;span&gt;\
      $\
      &lt;input\
        ref=&quot;input&quot;\
        v-bind:value=&quot;value&quot;\
        v-on:input=&quot;updateValue($event.target.value)&quot;\
      &gt;\
    &lt;/span&gt;\
  &apos;,
  props: [&apos;value&apos;],
  methods: {
    // 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制
    updateValue: function (value) {
      var formattedValue = value
        // 删除两侧的空格符
        .trim()
        // 保留 2 小数位
        .slice(0, value.indexOf(&apos;.&apos;) + 3)
      // 如果值不统一，手动覆盖以保持一致
      if (formattedValue !== value) {
        this.$refs.input.value = formattedValue
      }
      // 通过 input 事件发出数值
      this.$emit(&apos;input&apos;, Number(formattedValue))
    }
  }
})
$  
</code></pre><p>上面的实现方式太过理想化了。 比如，用户甚至可以输入多个小数点或句号 - 哦哦！因此我们需要一个更有意义的例子，下面是一个更加完善的货币过滤器：  </p>
<p>这个接口不仅仅可以用来连接组件内部的表单输入，也很容易集成你自己创造的输入类型。想象一下：</p>
<pre><code>&lt;voice-recognizer v-model=&quot;question&quot;&gt;&lt;/voice-recognizer&gt;
&lt;webcam-gesture-reader v-model=&quot;gesture&quot;&gt;&lt;/webcam-gesture-reader&gt;
&lt;webcam-retinal-scanner v-model=&quot;retinalImage&quot;&gt;&lt;/webcam-retinal-scanner&gt;
</code></pre><h4 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h4><p>有时候非父子关系的组件也需要通信。在简单的场景下，使用一个空的 Vue 实例作为中央事件总线：</p>
<pre><code>var bus = new Vue()
// 触发组件 A 中的事件
bus.$emit(&apos;id-selected&apos;, 1)
// 在组件 B 创建的钩子中监听事件
bus.$on(&apos;id-selected&apos;, function (id) {
  // ...
})
</code></pre><p>在更多复杂的情况下，你应该考虑使用专门的 状态管理模式.</p>
<h3 id="使用-Slot-分发内容"><a href="#使用-Slot-分发内容" class="headerlink" title="使用 Slot 分发内容"></a>使用 Slot 分发内容</h3><p>在使用组件时，常常要像这样组合它们：</p>
<pre><code>&lt;app&gt;
  &lt;app-header&gt;&lt;/app-header&gt;
  &lt;app-footer&gt;&lt;/app-footer&gt;
&lt;/app&gt;
</code></pre><p>注意两点：</p>
<ol>
<li><app> 组件不知道它的挂载点会有什么内容。挂载点的内容是由<app>的父组件决定的。</li>
<li><app> 组件很可能有它自己的模版。</li>
</ol>
<p>为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 内容分发 (或 “transclusion” 如果你熟悉 Angular)。Vue.js 实现了一个内容分发 API ，参照了当前 Web 组件规范草案，使用特殊的 <slot> 元素作为原始内容的插槽。</p>
<h4 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h4><p>在深入内容分发 API 之前，我们先明确内容的编译作用域。假定模板为：</p>
<pre><code>&lt;child-component&gt;
  {{ message }}
&lt;/child-component&gt;
</code></pre><p>message 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：  </p>
<p>父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。  </p>
<p>一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法： </p>
<pre><code>&lt;!-- 无效 --&gt;
&lt;child-component v-show=&quot;someChildProperty&quot;&gt;&lt;/child-component&gt;
</code></pre><p>假定 someChildProperty 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。  </p>
<p>如果要绑定子组件内的指令到一个组件的根节点，应当在它的模板内这么做：</p>
<pre><code>Vue.component(&apos;child-component&apos;, {
  // 有效，因为是在正确的作用域内
  template: &apos;&lt;div v-show=&quot;someChildProperty&quot;&gt;Child&lt;/div&gt;&apos;,
  data: function () {
    return {
      someChildProperty: true
    }
  }
})
</code></pre><p>类似地，分发内容是在父组件作用域内编译。</p>
<h4 id="单个-Slot"><a href="#单个-Slot" class="headerlink" title="单个 Slot"></a>单个 Slot</h4><p>除非子组件模板包含至少一个 <slot> 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。  </p>
<p>最初在 <slot> 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。  </p>
<p>假定 my-component 组件有下面模板：</p>
<pre><code>&lt;div&gt;
  &lt;h2&gt;我是子组件的标题&lt;/h2&gt;
  &lt;slot&gt;
    只有在没有要分发的内容时才会显示。
  &lt;/slot&gt;
&lt;/div&gt;
父组件模版：
&lt;div&gt;
  &lt;h1&gt;我是父组件的标题&lt;/h1&gt;
  &lt;my-component&gt;
    &lt;p&gt;这是一些初始内容&lt;/p&gt;
    &lt;p&gt;这是更多的初始内容&lt;/p&gt;
  &lt;/my-component&gt;
&lt;/div&gt;
</code></pre><p>渲染结果：</p>
<pre><code>&lt;div&gt;
  &lt;h1&gt;我是父组件的标题&lt;/h1&gt;
  &lt;div&gt;
    &lt;h2&gt;我是子组件的标题&lt;/h2&gt;
    &lt;p&gt;这是一些初始内容&lt;/p&gt;
    &lt;p&gt;这是更多的初始内容&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><h4 id="具名-Slot"><a href="#具名-Slot" class="headerlink" title="具名 Slot"></a>具名 Slot</h4><p><slot> 元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素。  </p>
<p>仍然可以有一个匿名 slot ，它是默认 slot ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。  </p>
<p>例如，假定我们有一个 app-layout 组件，它的模板为：</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre><p>父组件模版：</p>
<pre><code>&lt;app-layout&gt;
  &lt;h1 slot=&quot;header&quot;&gt;这里可能是一个页面标题&lt;/h1&gt;
  &lt;p&gt;主要内容的一个段落。&lt;/p&gt;
  &lt;p&gt;另一个主要段落。&lt;/p&gt;
  &lt;p slot=&quot;footer&quot;&gt;这里有一些联系信息&lt;/p&gt;
&lt;/app-layout&gt;
</code></pre><p>渲染结果为：</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
  &lt;header&gt;
    &lt;h1&gt;这里可能是一个页面标题&lt;/h1&gt;
  &lt;/header&gt;
  &lt;main&gt;
    &lt;p&gt;主要内容的一个段落。&lt;/p&gt;
    &lt;p&gt;另一个主要段落。&lt;/p&gt;
  &lt;/main&gt;
  &lt;footer&gt;
    &lt;p&gt;这里有一些联系信息&lt;/p&gt;
  &lt;/footer&gt;
&lt;/div&gt;
</code></pre><p>在组合组件时，内容分发 API 是非常有用的机制。</p>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>2.1.0 新增  </p>
<p>作用域插槽是一种特殊类型的插槽，用作使用一个（能够传递数据到）可重用模板替换已渲染元素。  </p>
<p>在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：</p>
<pre><code>&lt;div class=&quot;child&quot;&gt;
  &lt;slot text=&quot;hello from child&quot;&gt;&lt;/slot&gt;
&lt;/div&gt;
</code></pre><p>在父级中，具有特殊属性 scope 的 <template> 元素，表示它是作用域插槽的模板。scope 的值对应一个临时变量名，此变量接收从子组件中传递的 prop 对象：</p>
<pre><code>&lt;div class=&quot;parent&quot;&gt;
  &lt;child&gt;
    &lt;template scope=&quot;props&quot;&gt;
      &lt;span&gt;hello from parent&lt;/span&gt;
      &lt;span&gt;{{ props.text }}&lt;/span&gt;
    &lt;/template&gt;
  &lt;/child&gt;
&lt;/div&gt;
</code></pre><p>如果我们渲染以上结果，得到的输出会是：</p>
<pre><code>&lt;div class=&quot;parent&quot;&gt;
  &lt;div class=&quot;child&quot;&gt;
    &lt;span&gt;hello from parent&lt;/span&gt;
    &lt;span&gt;hello from child&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项：</p>
<pre><code>&lt;my-awesome-list :items=&quot;items&quot;&gt;
  &lt;!-- 作用域插槽也可以在这里命名 --&gt;
  &lt;template slot=&quot;item&quot; scope=&quot;props&quot;&gt;
    &lt;li class=&quot;my-fancy-item&quot;&gt;{{ props.text }}&lt;/li&gt;
  &lt;/template&gt;
&lt;/my-awesome-list&gt;
</code></pre><p>列表组件的模板：</p>
<pre><code>&lt;ul&gt;
  &lt;slot name=&quot;item&quot;
    v-for=&quot;item in items&quot;
    :text=&quot;item.text&quot;&gt;
    &lt;!-- fallback content here --&gt;
  &lt;/slot&gt;
&lt;/ul&gt;
</code></pre><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 <component> 元素，动态地绑定到它的 is 特性：</p>
<pre><code>var vm = new Vue({
  el: &apos;#example&apos;,
  data: {
    currentView: &apos;home&apos;
  },
  components: {
    home: { /* ... */ },
    posts: { /* ... */ },
    archive: { /* ... */ }
  }
})
&lt;component v-bind:is=&quot;currentView&quot;&gt;
  &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;
&lt;/component&gt;
</code></pre><p>也可以直接绑定到组件对象上：</p>
<pre><code>var Home = {
  template: &apos;&lt;p&gt;Welcome home!&lt;/p&gt;&apos;
}
var vm = new Vue({
  el: &apos;#example&apos;,
  data: {
    currentView: Home
  }
})
</code></pre><h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数：</p>
<pre><code>&lt;keep-alive&gt;
  &lt;component :is=&quot;currentView&quot;&gt;
    &lt;!-- 非活动组件将被缓存！ --&gt;
  &lt;/component&gt;
&lt;/keep-alive&gt;
</code></pre><p>在API 参考查看更多 <keep-alive> 的细节。  </p>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><h4 id="编写可复用组件"><a href="#编写可复用组件" class="headerlink" title="编写可复用组件"></a>编写可复用组件</h4><p>在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。  </p>
<p>Vue 组件的 API 来自三部分 - props, events 和 slots ：</p>
<ol>
<li>Props 允许外部环境传递数据给组件</li>
<li>Events 允许组件触发外部环境的副作用</li>
<li>Slots 允许外部环境将额外的内容组合在组件中。</li>
</ol>
<p>使用 v-bind 和 v-on 的简写语法，模板的缩进清楚且简洁：</p>
<pre><code>&lt;my-component
  :foo=&quot;baz&quot;
  :bar=&quot;qux&quot;
  @event-a=&quot;doThis&quot;
  @event-b=&quot;doThat&quot;
&gt;
  &lt;img slot=&quot;icon&quot; src=&quot;...&quot;&gt;
  &lt;p slot=&quot;main-text&quot;&gt;Hello!&lt;/p&gt;
&lt;/my-component&gt;
</code></pre><h4 id="子组件索引"><a href="#子组件索引" class="headerlink" title="子组件索引"></a>子组件索引</h4><p>尽管有 props 和 events ，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 ref 为子组件指定一个索引 ID 。例如：</p>
<pre><code>&lt;div id=&quot;parent&quot;&gt;
  &lt;user-profile ref=&quot;profile&quot;&gt;&lt;/user-profile&gt;
&lt;/div&gt;
var parent = new Vue({ el: &apos;#parent&apos; })
// 访问子组件
var child = parent.$refs.profile
</code></pre><p>当 ref 和 v-for 一起使用时， ref 是一个数组或对象，包含相应的子组件。  </p>
<p><code>$refs</code> 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 <code>$refs</code> 。</p>
<h4 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h4><p>在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单， Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：</p>
<pre><code>Vue.component(&apos;async-example&apos;, function (resolve, reject) {
  setTimeout(function () {
    // Pass the component definition to the resolve callback
    resolve({
      template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos;
    })
  }, 1000)
})
</code></pre><p>工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：Webpack 的代码分割功能：  </p>
<pre><code>Vue.component(&apos;async-webpack-example&apos;, function (resolve) {
  // 这个特殊的 require 语法告诉 webpack
  // 自动将编译后的代码分割成不同的块，
  // 这些块将通过 Ajax 请求自动下载。
  require([&apos;./my-async-component&apos;], resolve)
})
</code></pre><p>你可以使用 Webpack 2 + ES2015 的语法返回一个 Promise resolve 函数：  </p>
<pre><code>Vue.component(
  &apos;async-webpack-example&apos;,
  () =&gt; System.import(&apos;./my-async-component&apos;)
)
</code></pre><p>如果你是 Browserify 用户,可能就无法使用异步组件了,它的作者已经表明 Browserify 是不支持异步加载的。Browserify 社区发现 一些解决方法，可能有助于已存在的复杂应用。对于其他场景，我们推荐简单实用 Webpack 构建，一流的异步支持</p>
<h4 id="组件命名约定"><a href="#组件命名约定" class="headerlink" title="组件命名约定"></a>组件命名约定</h4><p>当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase 。Vue 不关心这个。</p>
<pre><code>// 在组件定义中
components: {
  // 使用 kebab-case 形式注册
  &apos;kebab-cased-component&apos;: { /* ... */ },
  // register using camelCase
  &apos;camelCasedComponent&apos;: { /* ... */ },
  // register using TitleCase
  &apos;TitleCasedComponent&apos;: { /* ... */ }
}
</code></pre><p>在 HTML 模版中，请使用 kebab-case 形式：</p>
<pre><code>&lt;!-- 在HTML模版中始终使用 kebab-case --&gt;
&lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt;
&lt;camel-cased-component&gt;&lt;/camel-cased-component&gt;
&lt;title-cased-component&gt;&lt;/title-cased-component&gt;
</code></pre><p>当使用字符串模式时，可以不受 HTML 的 case-insensitive 限制。这意味实际上在模版中，你可以使用 camelCase 、 TitleCase 或者 kebab-case 来引用：</p>
<pre><code>&lt;!-- 在字符串模版中可以用任何你喜欢的方式! --&gt;
&lt;my-component&gt;&lt;/my-component&gt;
&lt;myComponent&gt;&lt;/myComponent&gt;
&lt;MyComponent&gt;&lt;/MyComponent&gt;
</code></pre><p>如果组件未经 slot 元素传递内容，你甚至可以在组件名后使用 / 使其自闭合：</p>
<pre><code>&lt;my-component/&gt;
</code></pre><p>当然，这只在字符串模版中有效。因为自闭的自定义元素是无效的 HTML ，浏览器原生的解析器也无法识别它。  </p>
<h4 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a>递归组件</h4><p>组件在它的模板内可以递归地调用自己，不过，只有当它有 name 选项时才可以：</p>
<pre><code>name: &apos;unique-name-of-my-component&apos;
</code></pre><p>当你利用Vue.component全局注册了一个组件, 全局的ID作为组件的 name 选项，被自动设置.</p>
<pre><code>Vue.component(&apos;unique-name-of-my-component&apos;, {
  // ...
})
</code></pre><p>如果你不谨慎, 递归组件可能导致死循环:</p>
<pre><code>name: &apos;stack-overflow&apos;,
template: &apos;&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;&apos;
</code></pre><p>上面组件会导致一个错误 “max stack size exceeded” ，所以要确保递归调用有终止条件 (比如递归调用时使用 v-if 并让他最终返回 false )。  </p>
<h4 id="Circular-References-Between-Components"><a href="#Circular-References-Between-Components" class="headerlink" title="Circular References Between Components"></a>Circular References Between Components</h4><p>Let’s say you’re building a file directory tree, like in Finder or File Explorer. You might have a tree-folder component with this template:  </p>
<pre><code>&lt;p&gt;
  &lt;span&gt;{{ folder.name }}&lt;/span&gt;
  &lt;tree-folder-contents :children=&quot;folder.children&quot;/&gt;
&lt;/p&gt;
Then a tree-folder-contents component with this template:
&lt;ul&gt;
  &lt;li v-for=&quot;child in children&quot;&gt;
    &lt;tree-folder v-if=&quot;child.children&quot; :folder=&quot;child&quot;/&gt;
    &lt;span v-else&gt;{{ child.name }}&lt;/span&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>When you look closely, you’ll see that these components will actually be each other’s descendent and ancestor in the render tree - a paradox! When registering components globally with Vue.component, this paradox is resolved for you automatically. If that’s you, you can stop reading here.  </p>
<p>However, if you’re requiring/importing components using a module system, e.g. via Webpack or Browserify, you’ll get an error:  </p>
<pre><code>Failed to mount component: template or render function not defined.  
</code></pre><p>To explain what’s happening, I’ll call our components A and B. The module system sees that it needs A, but first A needs B, but B needs A, but A needs B, etc, etc. It’s stuck in a loop, not knowing how to fully resolve either component without first resolving the other. To fix this, we need to give the module system a point at which it can say, “A needs B eventually, but there’s no need to resolve B first.”  </p>
<p>In our case, I’ll make that point the tree-folder component. We know the child that creates the paradox is the tree-folder-contents component, so we’ll wait until the beforeCreate lifecycle hook to register it:</p>
<pre><code>beforeCreate: function () {
  this.$options.components.TreeFolderContents = require(&apos;./tree-folder-contents.vue&apos;)
}
</code></pre><p>Problem solved!</p>
<h4 id="内联模版"><a href="#内联模版" class="headerlink" title="内联模版"></a>内联模版</h4><p>如果子组件有 inline-template 特性，组件将把它的内容当作它的模板，而不是把它当作分发内容。这让模板更灵活。</p>
<pre><code>&lt;my-component inline-template&gt;
  &lt;div&gt;
    &lt;p&gt;These are compiled as the component&apos;s own template.&lt;/p&gt;
    &lt;p&gt;Not parent&apos;s transclusion content.&lt;/p&gt;
  &lt;/div&gt;
&lt;/my-component&gt;
</code></pre><p>但是 inline-template 让模板的作用域难以理解。最佳实践是使用 template 选项在组件内定义模板或者在 .vue 文件中使用 template 元素。</p>
<h4 id="X-Templates"><a href="#X-Templates" class="headerlink" title="X-Templates"></a>X-Templates</h4><p>另一种定义模版的方式是在 JavaScript 标签里使用 text/x-template 类型，并且指定一个id。例如：</p>
<pre><code>&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt;
  &lt;p&gt;Hello hello hello&lt;/p&gt;
&lt;/script&gt;
Vue.component(&apos;hello-world&apos;, {
  template: &apos;#hello-world-template&apos;
})
</code></pre><p>这在有很多模版或者小的应用中有用，否则应该避免使用，因为它将模版和组件的其他定义隔离了。</p>
<h4 id="使用-v-once-的低级静态组件-Cheap-Static-Component"><a href="#使用-v-once-的低级静态组件-Cheap-Static-Component" class="headerlink" title="使用 v-once 的低级静态组件(Cheap Static Component)"></a>使用 v-once 的低级静态组件(Cheap Static Component)</h4><p>尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来，就像这样：</p>
<pre><code>Vue.component(&apos;terms-of-service&apos;, {
  template: &apos;\
    &lt;div v-once&gt;\
      &lt;h1&gt;Terms of Service&lt;/h1&gt;\
      ... a lot of static content ...\
    &lt;/div&gt;\
  &apos;
})
</code></pre></script></li></ul>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持技术分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="http://www.luanmingli.com/static/image/wechat-reward-image.png" alt="卓越 WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="http://www.luanmingli.com/static/image/alipay-reward-image.png" alt="卓越 Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavsScript/" rel="tag">#JavsScript</a>
          
            <a href="/tags/vuejs/" rel="tag">#vuejs</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/19/vuejs-9/" rel="next" title="Vue.js——9.表单控件绑定">
                <i class="fa fa-chevron-left"></i> Vue.js——9.表单控件绑定
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/01/24/vuejs-advanced/" rel="prev" title="Vue.js——进阶(一)">
                Vue.js——进阶(一) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/01/21/vuejs-10/"
           data-title="Vue.js——10.表单控件绑定" data-url="http://yoursite.com/2017/01/21/vuejs-10/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://www.luanmingli.com/static/image/head.png"
               alt="卓越" />
          <p class="site-author-name" itemprop="name">卓越</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">125</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">67</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://github.com/Lmingli" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是组件？"><span class="nav-number">1.</span> <span class="nav-text">什么是组件？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用组件"><span class="nav-number">2.</span> <span class="nav-text">使用组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注册"><span class="nav-number">2.1.</span> <span class="nav-text">注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部注册"><span class="nav-number">2.2.</span> <span class="nav-text">局部注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOM-模版解析说明"><span class="nav-number">2.3.</span> <span class="nav-text">DOM 模版解析说明</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2013 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">卓越</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"luanmingli"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

</body>
</html>
